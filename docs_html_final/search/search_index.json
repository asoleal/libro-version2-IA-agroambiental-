{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Matem\u00e1ticas para Inteligencia Artificial Agroambiental","text":"<p>\u00a1Bienvenido! Este libro es un recurso educativo de c\u00f3digo abierto dise\u00f1ado para cerrar la brecha entre las matem\u00e1ticas abstractas, la programaci\u00f3n en Python y los desaf\u00edos reales del sector agropecuario y ambiental.</p>"},{"location":"index.html#objetivo-del-libro","title":"\ud83c\udfaf Objetivo del Libro","text":"<p>La Inteligencia Artificial (IA) est\u00e1 transformando la agricultura, desde la predicci\u00f3n de cosechas hasta la optimizaci\u00f3n de recursos h\u00eddricos. Sin embargo, entender los algoritmos de IA requiere una base s\u00f3lida de \u00c1lgebra Lineal.</p> <p>Este libro no solo explica la teor\u00eda matem\u00e1tica (matrices, vectores, sistemas de ecuaciones), sino que demuestra para qu\u00e9 sirven mediante casos de estudio aplicados:</p> <ul> <li>\ud83c\udf31 Modelado de cultivos.</li> <li>\ud83d\udca7 Sistemas de riego automatizados.</li> <li>\ud83e\uddea An\u00e1lisis de suelos.</li> <li>\ud83d\udef0\ufe0f Procesamiento de im\u00e1genes satelitales.</li> </ul>"},{"location":"index.html#herramientas-utilizadas","title":"\ud83d\udee0\ufe0f Herramientas Utilizadas","text":"<p>El enfoque es totalmente pr\u00e1ctico (\"Aprender haciendo\"). En cada cap\u00edtulo encontrar\u00e1s:</p> <ol> <li>Fundamentos Matem\u00e1ticos: Explicaciones claras con notaci\u00f3n rigurosa.</li> <li>Implementaci\u00f3n en Python: Uso de bibliotecas est\u00e1ndar como <code>NumPy</code> y <code>Matplotlib</code>.</li> <li>Ejemplos Agroambientales: Problemas contextualizados en la realidad del campo.</li> </ol> <p>\u00bfPara qui\u00e9n es este libro?</p> <p>Ideal para estudiantes de ingenier\u00eda agron\u00f3mica, ambiental, sistemas, y profesionales interesados en aplicar ciencia de datos al sector primario.</p>"},{"location":"index.html#estructura-del-contenido","title":"\ud83d\ude80 Estructura del Contenido","text":"<p>El libro avanza progresivamente desde los conceptos b\u00e1sicos hasta aplicaciones complejas:</p> <ul> <li>Estructuras de Datos: Escalares, vectores y matrices.</li> <li>Operaciones: C\u00f3mo manipular datos num\u00e9ricos.</li> <li>Sistemas de Ecuaciones: Resoluci\u00f3n de problemas de balance de nutrientes y mezclas.</li> <li>Regresi\u00f3n Lineal: Predicci\u00f3n de variables clim\u00e1ticas y de rendimiento.</li> </ul> <p> \"La agricultura del futuro se escribe con c\u00f3digo y se fundamenta en matem\u00e1ticas.\" </p>"},{"location":"estructura-datos.html","title":"Estructuras de datos: escalares, vectores, matrices y tensores","text":""},{"location":"estructura-datos.html#escalar-rango-0","title":"Escalar (Rango 0)","text":"<p>Un escalar es un n\u00famero real que representa una cantidad simple, sin direcci\u00f3n ni estructura interna. En ciencia de datos, los escalares suelen ser hiperpar\u00e1metros, m\u00e9tricas de desempe\u00f1o o mediciones puntuales.</p> <p>Ejemplos:</p> <ul> <li> <p>La tasa de aprendizaje en un modelo de predicci\u00f3n de rendimiento: \\(\\eta = 0{,}01\\),</p> </li> <li> <p>El error cuadr\u00e1tico medio (MSE) de un modelo de predicci\u00f3n de peso animal: \\(\\text{MSE} = 4{,}3\\),</p> </li> <li> <p>La humedad del suelo en un punto espec\u00edfico: \\(28{,}5\\%\\),</p> </li> <li> <p>La concentraci\u00f3n horaria de \\(\\mathrm{PM}_{2.5}\\) en una estaci\u00f3n ambiental: \\(32{,}7\\ \\mu\\text{g/m}^3\\),</p> </li> <li> <p>El presupuesto total asignado a un programa de sostenibilidad: \\(1{,}25\\) millones de pesos.</p> </li> </ul>"},{"location":"estructura-datos.html#vector-rango-1","title":"Vector (Rango 1)","text":"<p>Un vector es una lista ordenada de n\u00fameros que describe un objeto o fen\u00f3meno mediante m\u00faltiples atributos medibles. Cada componente corresponde a una variable relevante en el contexto de an\u00e1lisis.</p> <p>Ejemplos:</p> <ul> <li> <p>Agron\u00f3mico: \\(\\mathbf{x} = (120, 50, 3, 6{,}2)^\\top\\) \u2192 (N, P, K en kg/ha; pH del suelo)[^1],</p> </li> <li> <p>Zoot\u00e9cnico: \\(\\mathbf{x} = (650, 3{,}8, 42, 18)^\\top\\) \u2192 (peso en kg, producci\u00f3n lechera en L/d\u00eda, % grasa, edad en meses),</p> </li> <li> <p>Agroindustrial: \\(\\mathbf{x} = (85, 120, 0{,}45)^\\top\\) \u2192 (temperatura del horno en \u00b0C, tiempo de cocci\u00f3n en min, humedad final del producto),</p> </li> <li> <p>Ambiental: \\(\\mathbf{x} = (45, 28, 32, 65, 1{,}2)^\\top\\) \u2192 (\\(\\mathrm{PM}_{10}\\), \\(\\mathrm{PM}_{2.5}\\), \\(\\mathrm{NO}_2\\), \\(\\mathrm{O}_3\\), \\(\\mathrm{CO}\\) en \\(\\mu\\text{g/m}^3\\)),</p> </li> <li> <p>Administrativo: \\(\\mathbf{x} = (320, 95, 210, 75)^\\top\\) \u2192 (presupuesto en millones de pesos para: infraestructura, capacitaci\u00f3n, operaci\u00f3n, monitoreo ambiental).</p> </li> </ul> <p>Los vectores son la unidad b\u00e1sica de representaci\u00f3n en modelos de aprendizaje autom\u00e1tico, ya que permiten tratar cada observaci\u00f3n como un punto en un espacio multidimensional.</p>"},{"location":"estructura-datos.html#matriz-rango-2","title":"Matriz (Rango 2)","text":"<p>Una matriz es un arreglo rectangular de n\u00fameros reales ordenados en filas y columnas. Si bien visualmente se asemeja a una tabla, en \u00e1lgebra lineal aplicada y ciencia de datos posee una dualidad fundamental:</p> <ol> <li> <p>Como estructura de datos (Est\u00e1tica): Es un contenedor donde las filas suelen representar observaciones (ej. pacientes, plantas, transacciones) y las columnas variables (ej. edad, altura, costo).</p> </li> <li> <p>Como operador (Din\u00e1mica): Representa una transformaci\u00f3n lineal que act\u00faa sobre vectores, capaz de rotar, escalar o proyectar datos en el espacio geom\u00e9trico.</p> </li> </ol>"},{"location":"estructura-datos.html#definicion-formal","title":"Definici\u00f3n formal","text":"<p>Una matriz \\(\\mathbf{A}\\) de dimensiones \\(m \\times n\\) es un elemento del espacio vectorial \\(\\mathbb{R}^{m \\times n}\\). Se denota expl\u00edcitamente como:</p> \\[\\mathbf{A} =  \\begin{pmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{m1} &amp; a_{m2} &amp; \\cdots &amp; a_{mn} \\end{pmatrix}_{m\\times n} \\in \\mathbb{R}^{m \\times n}.\\] <p>Donde:</p> <ul> <li> <p>\\(m\\) es el n\u00famero de filas (eje 0 en librer\u00edas como NumPy o PyTorch).</p> </li> <li> <p>\\(n\\) es el n\u00famero de columnas (eje 1).</p> </li> <li> <p>\\(a_{ij} \\in \\mathbb{R}\\) es la entrada escalar ubicada en la fila \\(i\\) y columna \\(j\\).</p> </li> </ul>"},{"location":"estructura-datos.html#descomposicion-en-vectores-filas-vs-columnas","title":"Descomposici\u00f3n en Vectores: Filas vs. Columnas","text":"<p>Para entender las operaciones matriciales en IA, es crucial no ver la matriz como un bloque s\u00f3lido, sino como una colecci\u00f3n de vectores.</p>"},{"location":"estructura-datos.html#1-vision-por-columnas-espacio-de-caracteristicas","title":"1. Visi\u00f3n por Columnas (Espacio de Caracter\u00edsticas)","text":"<p>Podemos ver a \\(\\mathbf{A}\\) como una colecci\u00f3n de \\(n\\) vectores columna verticales. Esta visi\u00f3n es \u00fatil en \u00e1lgebra lineal para entender conceptos como independencia lineal o bases.</p> \\[\\mathbf{A} =  \\begin{pmatrix} | &amp; | &amp; &amp; | \\\\ \\mathbf{c}_1 &amp; \\mathbf{c}_2 &amp; \\cdots &amp; \\mathbf{c}_n \\\\ | &amp; | &amp; &amp; | \\end{pmatrix},  \\quad \\text{donde } \\mathbf{c}_j \\in \\mathbb{R}^m.\\]"},{"location":"estructura-datos.html#2-vision-por-filas-espacio-de-muestras","title":"2. Visi\u00f3n por Filas (Espacio de Muestras)","text":"<p>Podemos ver a \\(\\mathbf{A}\\) como una pila de \\(m\\) vectores fila horizontales. Esta es la visi\u00f3n est\u00e1ndar en Data Science, donde cada fila es un objeto de estudio.</p> \\[\\mathbf{A} =  \\begin{pmatrix} \\text{---} &amp; \\mathbf{r}_1 &amp; \\text{---} \\\\ \\text{---} &amp; \\mathbf{r}_2 &amp; \\text{---} \\\\  &amp; \\vdots &amp; \\\\ \\text{---} &amp; \\mathbf{r}_m &amp; \\text{---} \\end{pmatrix},  \\quad \\text{donde } \\mathbf{r}_i \\in \\mathbb{R}^{1 \\times n}.\\]"},{"location":"estructura-datos.html#la-matriz-como-dataset-ejemplo-agronomico","title":"La Matriz como Dataset: Ejemplo Agron\u00f3mico","text":"<p>Considere un estudio de suelos con 100 muestras (\\(m=100\\)) y 5 variables qu\u00edmicas (\\(n=5\\)). La matriz de datos \\(\\mathbf{X} \\in \\mathbb{R}^{100 \\times 5}\\) se estructura de la siguiente forma, donde cada fila es una\"foto qu\u00edmica\" de una parcela distinta:</p> \\[\\mathbf{X} =  \\begin{array}{c|ccccc}  &amp; \\text{N} &amp; \\text{P} &amp; \\text{K} &amp; \\text{pH} &amp; \\text{M.O.} \\\\ \\hline \\text{Muestra 1} &amp; 110 &amp; 45 &amp; 2{,}8 &amp; 6{,}1 &amp; 3{,}5 \\\\ \\text{Muestra 2} &amp; 130 &amp; 55 &amp; 3{,}1 &amp; 6{,}3 &amp; 4{,}1 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ \\text{Muestra 100} &amp; 100 &amp; 50 &amp; 2{,}9 &amp; 5{,}9 &amp; 3{,}2 \\end{array}\\] <p>En este contexto, el \u00e1lgebra lineal nos permite operar sobre todo el conjunto de datos simult\u00e1neamente (por ejemplo, normalizar la columna del pH para todas las muestras a la vez) mediante una t\u00e9cnica computacional conocida como vectorizaci\u00f3n, evitando el uso de bucles lentos.</p>"},{"location":"estructura-datos.html#tensor-rango-k-generalizacion-multidimensional","title":"Tensor: Rango \\(k\\), Generalizaci\u00f3n Multidimensional","text":"<p>Un tensor es la estructura de datos fundamental en inteligencia artificial. Matem\u00e1ticamente, representa una generalizaci\u00f3n de los conceptos de escalar, vector y matriz a un espacio de \\(K\\) dimensiones (denominadas modos o ejes).</p> <p>El rango (u orden) de un tensor es el n\u00famero de \u00edndices necesarios para localizar un elemento de forma un\u00edvoca. En t\u00e9rminos computacionales, esto coincide con el n\u00famero de dimensiones del arreglo (propiedad <code>.ndim</code> en Python).</p> <p>Jerarqu\u00eda de Tensores por su Rango:</p> <ul> <li> <p>Rango 0 (Escalar): Un \u00fanico n\u00famero \\(s \\in \\mathbb{R}\\). Representa una magnitud puntual (ej. la temperatura de un invernadero).</p> </li> <li> <p>Rango 1 (Vector): Una lista ordenada \\(\\mathbf{v} \\in \\mathbb{R}^{n_1}\\). Representa una l\u00ednea de datos o un perfil de atributos (ej. par\u00e1metros de suelo N, P, K).</p> </li> <li> <p>Rango 2 (Matriz): Una rejilla bidimensional \\(\\mathbf{M} \\in \\mathbb{R}^{n_1 \\times n_2}\\). Estructura est\u00e1ndar para bases de datos tabulares (filas por columnas).</p> </li> <li> <p>Rango 3 (Tensor de 3er orden): Un \"cubo\" de n\u00fameros \\(\\mathcal{T} \\in \\mathbb{R}^{n_1 \\times n_2 \\times n_3}\\). Com\u00fan en im\u00e1genes a color (Alto \\(\\times\\) Ancho \\(\\times\\) Canales RGB) como en la figura [fig:tensor_vis].</p> </li> <li> <p>Rango 4 (Tensor de 4to orden): Un conjunto de cubos \\(\\mathcal{T} \\in \\mathbb{R}^{n_1 \\times n_2 \\times n_3 \\times n_4}\\). Estructura t\u00edpica para batches (lotes) de im\u00e1genes en redes neuronales o series temporales de mapas satelitales.</p> </li> </ul> <p>Definici\u00f3n formal. Un tensor de orden \\(K\\) se define como un elemento de un espacio producto de \\(K\\) dimensiones:</p> \\[\\mathcal{T} \\in \\mathbb{R}^{d_1 \\times d_2 \\times \\dots \\times d_K}\\] <p>donde cada \\(d_i\\) representa la cardinalidad (tama\u00f1o) del \\(i\\)-\u00e9simo eje. Para acceder a una entrada espec\u00edfica, se requiere una tupla de \\(K\\) \u00edndices:</p> \\[t_{i_1, i_2, \\dots, i_K} = \\mathcal{T}(i_1, i_2, \\dots, i_K)\\] <p>Ingenier\u00eda Ambiental y Teledetecci\u00f3n</p> <p>El uso de tensores de rango 4 permite modelar la dispersi\u00f3n espaciotemporal de contaminantes. Los ejes representan: (1) Tiempo, (2) Latitud, (3) Longitud y (4) Tipo de contaminante (\\(\\mathrm{PM}_{2.5}, \\mathrm{O}_3\\), etc.). Esta estructura es la entrada para redes neuronales recurrentes-convolucionales (ConvLSTM).</p> Visualizaci\u00f3n del Tensor"},{"location":"estructura-datos.html#ejemplo-expl\u00edcito-tensor-de-rango-4-en-teledetecci\u00f3n-agr\u00edcola","title":"Ejemplo expl\u00edcito: tensor de rango 4 en teledetecci\u00f3n agr\u00edcola","text":"<p>Considere un estudio de monitoreo de cultivos en una regi\u00f3n agr\u00edcola mediante im\u00e1genes multiespectrales tomadas por un dron a lo largo de una temporada de crecimiento. Los datos se organizan naturalmente en un tensor de rango 4:</p> \\[\\mathcal{T} \\in \\mathbb{R}^{30 \\times 64 \\times 64 \\times 5}.\\] <p>Cada dimensi\u00f3n (modo) del tensor representa una caracter\u00edstica esencial del conjunto de datos:</p> <ul> <li> <p>Modo 1 (tiempo): \\(30\\) fechas de vuelo distribuidas a lo largo de la temporada (una imagen cada 3--4 d\u00edas).</p> </li> <li> <p>Modo 2 (altura): \\(64\\) filas de p\u00edxeles en cada imagen (resoluci\u00f3n espacial de \\(64 \\times 64\\) p\u00edxeles por parcela).</p> </li> <li> <p>Modo 3 (ancho): \\(64\\) columnas de p\u00edxeles.</p> </li> <li> <p>Modo 4 (bandas espectrales): \\(5\\) bandas capturadas por el sensor multiespectral:</p> <ol> <li> <p>Azul (450--515 nm),</p> </li> <li> <p>Verde (515--595 nm),</p> </li> <li> <p>Rojo (600--680 nm),</p> </li> <li> <p>Infrarrojo cercano -- NIR (770--890 nm),</p> </li> <li> <p>Borde rojo -- Red Edge (690--750 nm).</p> </li> </ol> </li> </ul> <p>Un elemento gen\u00e9rico del tensor se denota como:</p> \\[\\mathcal{T}(t, i, j, b) = \\text{valor de reflectancia en la fecha } t, \\text{ p\u00edxel } (i,j), \\text{ y banda } b,\\] <p>donde:</p> \\[\\begin{aligned}     t &amp;\\in \\{1, 2, \\dots, 30\\} \\\\     i &amp;\\in \\{1, 2, \\dots, 64\\} \\\\     j &amp;\\in \\{1, 2, \\dots, 64\\} \\\\     b &amp;\\in \\{1, 2, 3, 4, 5\\} \\end{aligned}\\] <p>Por ejemplo, el valor \\(\\mathcal{T}(15, 32, 45, 4) = 0.82\\) indica que, en la decimoquinta fecha de muestreo, el p\u00edxel ubicado en la fila 32 y columna 45 present\u00f3 una reflectancia relativa del 82% en la banda NIR. Este valor alto es t\u00edpico de vegetaci\u00f3n sana y se usa para calcular \u00edndices como el NDVI.</p> <p>Este tipo de tensor es la entrada est\u00e1ndar para arquitecturas de redes neuronales convolucionales 3D (3D-CNN) o modelos basados en transformers espaciotemporales, que predicen variables como rendimiento, estr\u00e9s h\u00eddrico o presencia de enfermedades a partir de la din\u00e1mica espectral y espacial del cultivo.</p> <p>Otros ejemplos pr\u00e1cticos con dimensiones expl\u00edcitas:</p> <ul> <li> <p>Serie temporal de im\u00e1genes satelitales (rango 4): \\(\\mathcal{T} \\in \\mathbb{R}^{36 \\times 512 \\times 512 \\times 6}\\)</p> <ul> <li> <p>Eje 1 (36): d\u00edas de observaci\u00f3n (una imagen cada 5 d\u00edas durante 180 d\u00edas),</p> </li> <li> <p>Ejes 2--3 (512\u00d7512): resoluci\u00f3n espacial de la parcela,</p> </li> <li> <p>Eje 4 (6): bandas espectrales disponibles en el sat\u00e9lite (e.g., Sentinel-2).</p> </li> </ul> <p>Este tensor es ideal para redes neuronales recurrentes o 3D-CNN que predicen rendimiento, fenolog\u00eda o presencia de plagas a partir de la din\u00e1mica del cultivo.</p> </li> <li> <p>Monitoreo de un hato lechero (rango 3): \\(\\mathcal{T} \\in \\mathbb{R}^{90 \\times 150 \\times 4}\\)</p> <ul> <li> <p>Eje 1 (90): d\u00edas de seguimiento (3 meses),</p> </li> <li> <p>Eje 2 (150): n\u00famero de vacas en el hato,</p> </li> <li> <p>Eje 3 (4): variables fisiol\u00f3gicas: temperatura corporal, actividad (pasos), rumia (min/d\u00eda), producci\u00f3n de leche (L/d\u00eda).</p> </li> </ul> <p>Este tensor permite detectar brotes de enfermedad (e.g., mastitis) mediante an\u00e1lisis de patrones an\u00f3malos en m\u00faltiples variables y animales simult\u00e1neamente.</p> </li> <li> <p>Ensayo factorial en invernadero (rango 4): \\(\\mathcal{T} \\in \\mathbb{R}^{5 \\times 4 \\times 10 \\times 8}\\)</p> <ul> <li> <p>Eje 1 (5): niveles de riego,</p> </li> <li> <p>Eje 2 (4): tipos de fertilizante,</p> </li> <li> <p>Eje 3 (10): repeticiones experimentales (macetas),</p> </li> <li> <p>Eje 4 (8): variables de respuesta: altura, n\u00famero de hojas, biomasa seca, contenido de nitr\u00f3geno, etc.</p> </li> </ul> <p>Este tensor estructura un dise\u00f1o experimental complejo y facilita el an\u00e1lisis multivariado de interacciones entre factores.</p> </li> <li> <p>Secuencia de video para navegaci\u00f3n rob\u00f3tica (rango 4): \\(\\mathcal{T} \\in \\mathbb{R}^{30 \\times 224 \\times 224 \\times 4}\\)</p> <ul> <li> <p>Eje 1 (30): fotogramas temporales (1 segundo de video a 30 fps),</p> </li> <li> <p>Ejes 2--3 (224\u00d7224): resoluci\u00f3n espacial de la c\u00e1mara del robot (redimensionada para una CNN),</p> </li> <li> <p>Eje 4 (4): canales de informaci\u00f3n sensorial (R, G, B y Depth/Profundidad).</p> </li> </ul> <p>Este tensor es la entrada t\u00edpica para sistemas de Visual Servoing o SLAM (Localizaci\u00f3n y Mapeo Simult\u00e1neos), permitiendo al robot distinguir objetos reales de sombras y calcular trayectorias libres de colisiones en entornos din\u00e1micos.</p> </li> </ul> <p>Teledetecci\u00f3n y Medio Ambiente</p> <p>Un tensor \\(\\mathcal{T} \\in \\mathbb{R}^{30 \\times 64 \\times 64 \\times 5}\\) permite a una red neuronal convolucional (CNN) detectar estr\u00e9s h\u00eddrico analizando la evoluci\u00f3n temporal de la reflectancia en la banda NIR (Infrarrojo Cercano).</p> <p>En la pr\u00e1ctica de la inteligencia artificial moderna ---dominada por librer\u00edas como <code>PyTorch</code> o <code>TensorFlow</code>---, el tensor evoluciona de una abstracci\u00f3n matem\u00e1tica a un objeto computacional de alto rendimiento. Se implementa como un arreglo multidimensional optimizado para ejecutarse en aceleradores de hardware (GPU/TPU) y con soporte nativo para la diferenciaci\u00f3n autom\u00e1tica. Esta infraestructura es la base com\u00fan que permite entrenar modelos complejos en cualquier dominio: desde la visi\u00f3n computacional en agricultura y la navegaci\u00f3n rob\u00f3tica, hasta la proyecci\u00f3n de escenarios financieros en administraci\u00f3n.</p>"},{"location":"estructura-datos.html#manejo-de-los-datos-en-python","title":"Manejo de los datos en Python","text":"<p>A continuaci\u00f3n, se presentan las formas para definir los datos en sus diferentes presentaciones:</p> <pre><code>import numpy as np\nimport torch\n\nprint(\"--- BLOQUE 1: CIENCIA DE DATOS (NumPy) ---\")\n\n# 1. Escalar (Rango 0)\ns = 28.5 \nprint(f\"Escalar (Humedad): {s} | Tipo: {type(s)}\")\n\n# 2. Vector (Rango 1): Perfil de suelo [N, P, K, pH]\nv = np.array([120, 50, 3, 6.2])\nprint(f\"Vector: {v} | Forma: {v.shape}\")\n\n# 3. Matriz (Rango 2): Ensayo con 3 parcelas y 2 variables (Rendimiento, pH)\nM = np.array([[110, 6.1], \n              [130, 6.3], \n              [100, 5.9]])\nprint(f\"Matriz (Parcelas x Vars):\\n{M}\")\n\n# Operaci\u00f3n de Slicing (Acceso a datos):\n# \"Deme el pH (columna 1) de la segunda parcela (fila 1)\"\nph_parcela_2 = M[1, 1] \nprint(f\"--&gt; pH de la parcela 2: {ph_parcela_2}\")\n\n\nprint(\"\\n--- BLOQUE 2: INTELIGENCIA ARTIFICIAL (PyTorch) ---\")\n\n# 4. Tensor Rango 3: Imagen individual para un robot (Canales, Alto, Ancho)\n# PyTorch prefiere el formato (C, H, W) para procesamiento\nimg_robot = torch.rand(3, 128, 128) \nprint(f\"Imagen Robot (C,H,W): {img_robot.shape} | Rango: {img_robot.ndim}\")\n\n# 5. Tensor Rango 4: Serie de Tiempo Satelital (Multidimensional)\n# Dimensiones: (Tiempo/Batch, Canales, Alto, Ancho)\n# Ejemplo: 10 fechas, 5 bandas espectrales, resoluci\u00f3n 64x64\nserie_satelital = torch.randn(10, 5, 64, 64)\n\nprint(f\"Serie Satelital: {serie_satelital.shape}\")\n\n# Acceso complejo: \n# \"Valor del pixel central (32,32) en la Banda Roja (\u00edndice 0) de la \n# \u00faltima fecha (\u00edndice -1)\"\npixel_val = serie_satelital[-1, 0, 32, 32]\nprint(f\"--&gt; Valor pixel espec\u00edfico: {pixel_val:.4f}\")\n</code></pre>"},{"location":"estructura-datos.html#salida","title":"Salida","text":"<pre><code>--- BLOQUE 1: CIENCIA DE DATOS (NumPy) ---\nEscalar (Humedad): 28.5 | Tipo: &lt;class 'float'&gt;\n\nVector: [120.  50.   3.   6.2] | Forma: (4,)\n\nMatriz (Parcelas x Vars):\n[[110.    6.1]\n [130.    6.3]\n [100.    5.9]]\n--&gt; pH de la parcela 2: 6.3\n\n--- BLOQUE 2: INTELIGENCIA ARTIFICIAL (PyTorch) ---\nImagen Robot (C,H,W): torch.Size([3, 128, 128]) | Rango: 3\n\nSerie Satelital: torch.Size([10, 5, 64, 64])\n\n--&gt; Valor pixel espec\u00edfico: -0.4281\n</code></pre>"},{"location":"estructura-datos.html#conceptos-fundamentales-de-vectores-en-mathbbrn","title":"Conceptos fundamentales de vectores en \\(\\mathbb{R}^n\\)","text":"<p>Antes de introducir las operaciones entre vectores, es esencial comprender su estructura interna y sus propiedades geom\u00e9tricas. En ciencia de datos agro-ambiental, los vectores en Rn representan observaciones multivariadas, y su an\u00e1lisis requiere comprender c\u00f3mo se comparan, c\u00f3mo se mide su tama\u00f1o y c\u00f3mo se orientan en el espacio.</p>"},{"location":"estructura-datos.html#transpuesta-de-vectores-y-matrices","title":"Transpuesta de vectores y matrices","text":"<p>La transposici\u00f3n es una operaci\u00f3n fundamental que reorganiza la estructura de los datos, invirtiendo sus dimensiones: transforma un arreglo de tama\u00f1o \\(m \\times n\\) en uno de \\(n \\times m\\). Geom\u00e9trica y algebraicamente, esto equivale a reflejar los elementos de la matriz respecto a su diagonal principal.</p> <p>En el contexto de la ciencia de datos y la modelaci\u00f3n, la transposici\u00f3n no es solo un cambio de formato, sino una herramienta indispensable para la alineaci\u00f3n dimensional. Es el paso previo necesario para realizar operaciones cr\u00edticas como el c\u00e1lculo del producto punto, la proyecci\u00f3n de vectores y la construcci\u00f3n de la matriz de covarianza, permitiendo as\u00ed relacionar variables y observaciones de manera coherente.</p>"},{"location":"estructura-datos.html#definicion","title":"Definici\u00f3n","text":"<p>Dado un vector columna \\(\\mathbf{x} \\in \\mathbb{R}^{n}\\) (o \\(\\mathbb{R}^{n\\times 1}\\)), definido expl\u00edcitamente como:</p> \\[\\mathbf{x} =  \\begin{pmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\end{pmatrix}\\] <p>Su transpuesta, denotada como \\(\\mathbf{x}^\\top\\), es el vector fila asociado en \\(\\mathbb{R}^{1 \\times n}\\):</p> \\[\\mathbf{x}^\\top =  \\begin{pmatrix} x_1 &amp; x_2 &amp; \\cdots &amp; x_n \\end{pmatrix}\\]"},{"location":"estructura-datos.html#definicion_1","title":"Definici\u00f3n","text":"<p>Dada una matriz \\(\\mathbf{A} \\in \\mathbb{R}^{m \\times n}\\), expresada expl\u00edcitamente como:</p> \\[\\mathbf{A} =  \\begin{pmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{m1} &amp; a_{m2} &amp; \\cdots &amp; a_{mn} \\end{pmatrix}_{m\\times n}\\] <p>Su transpuesta \\(\\mathbf{A}^\\top \\in \\mathbb{R}^{n \\times m}\\) se construye convirtiendo la fila \\(i\\) de \\(\\mathbf{A}\\) en la columna \\(i\\) de \\(\\mathbf{A}^\\top\\):</p> \\[\\mathbf{A}^\\top =  \\begin{pmatrix} a_{11} &amp; a_{21} &amp; \\cdots &amp; a_{m1} \\\\ a_{12} &amp; a_{22} &amp; \\cdots &amp; a_{m2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{1n} &amp; a_{2n} &amp; \\cdots &amp; a_{mn} \\end{pmatrix}_{n\\times m}\\] <p>Formalmente, se define por la propiedad de sus entradas:</p> \\[(\\mathbf{A}^\\top)_{ij} = a_{ji}, \\quad \\text{para todo } i=1,\\dots,n,\\; j=1,\\dots,m.\\] <p>Propiedades clave:</p> \\[\\begin{aligned}     (\\mathbf{A}^\\top)^\\top &amp;= \\mathbf{A} \\\\     (\\mathbf{A} + \\mathbf{B})^\\top &amp;= \\mathbf{A}^\\top + \\mathbf{B}^\\top \\\\     (\\alpha \\mathbf{A})^\\top &amp;= \\alpha \\mathbf{A}^\\top \\quad (\\text{para todo } \\alpha \\in \\mathbb{R}) \\\\     (\\mathbf{A} \\mathbf{B})^\\top &amp;= \\mathbf{B}^\\top \\mathbf{A}^\\top \\quad (\\text{el orden se invierte}) \\end{aligned}\\]"},{"location":"estructura-datos.html#relevancia-en-ciencia-de-datos","title":"Relevancia en ciencia de datos","text":"<ul> <li> <p>Producto punto: El producto escalar de dos vectores columna \\(\\mathbf{x}, \\mathbf{y} \\in \\mathbb{R}^n\\) se escribe como \\(\\mathbf{x}^\\top \\mathbf{y}\\), que resulta en un escalar. Esta notaci\u00f3n es la base de la similitud coseno y las proyecciones.</p> </li> <li> <p>Matriz de covarianza: Si \\(\\mathbf{X} \\in \\mathbb{R}^{m \\times n}\\) es una matriz de datos (filas = observaciones, columnas = variables), la matriz de covarianza se calcula como \\(\\mathbf{\\Sigma} = \\frac{1}{m-1} \\mathbf{X}^\\top \\mathbf{X}\\). La transposici\u00f3n permite alinear correctamente las variables para el c\u00e1lculo de covarianzas.</p> </li> <li> <p>Ajuste de modelos: En regresi\u00f3n lineal, el modelo \\(\\mathbf{y} = \\mathbf{X} \\pmb{\\beta} + \\pmb{\\varepsilon}\\) requiere que \\(\\mathbf{X}^\\top \\mathbf{X}\\) sea invertible para estimar \\(\\pmb{\\beta}\\), lo que depende directamente de la transposici\u00f3n.</p> </li> </ul> <p>Ejemplo num\u00e9rico. Considere una matriz de datos de un ensayo agron\u00f3mico con 2 parcelas y 3 variables (N, P, K):</p> \\[\\mathbf{X} = \\begin{pmatrix} 120 &amp; 50 &amp; 3 \\\\ 100 &amp; 60 &amp; 4 \\end{pmatrix}.\\] <p>Su transpuesta es:</p> \\[\\mathbf{X}^\\top = \\begin{pmatrix} 120 &amp; 100 \\\\ 50 &amp; 60 \\\\ 3 &amp; 4 \\end{pmatrix}.\\]"},{"location":"estructura-datos.html#implementacion-computacional-y-matices-practicos","title":"Implementaci\u00f3n Computacional y Matices Pr\u00e1cticos","text":"<p>Aunque la definici\u00f3n matem\u00e1tica es estricta, en librer\u00edas como <code>NumPy</code> o <code>PyTorch</code> existe una distinci\u00f3n t\u00e9cnica importante entre un arreglo unidimensional (plano) y un vector columna formal.</p> <ul> <li> <p>Arreglo 1D (Rank-1): Tiene forma <code>(n,)</code>. Su transpuesta <code>.T</code> no altera nada (sigue siendo plano). Es eficiente en memoria pero peligroso en \u00e1lgebra lineal estricta.</p> </li> <li> <p>Vector Columna (Rank-2): Tiene forma <code>(n, 1)</code>. Su transpuesta cambia la forma a <code>(1, n)</code>, comport\u00e1ndose exactamente como la teor\u00eda matem\u00e1tica.</p> </li> </ul> <p>A continuaci\u00f3n, implementamos estos conceptos y verificamos la propiedad cr\u00edtica de la inversi\u00f3n del producto \\((\\mathbf{AB})^\\top = \\mathbf{B}^\\top \\mathbf{A}^\\top\\).</p> <pre><code>import torch\n\nprint(\"--- 1. EL 'ENGA\u00d1O' DE LOS VECTORES 1D ---\")\n# Vector plano (com\u00fan en programaci\u00f3n b\u00e1sica)\nv_flat = torch.tensor([1, 2, 3]) \nprint(f\"Vector plano: {v_flat.shape}\")\nprint(f\"Transpuesta v.T: {v_flat.T.shape} (\u00a1No cambia!)\")\n\n# Vector Matem\u00e1tico (Columna expl\u00edcita)\n# Usamos .unsqueeze(1) o definimos los corchetes dobles [[...]]\nv_col = v_flat.unsqueeze(1) # Transforma (3) -&gt; (3, 1)\nprint(f\"Vector Columna:\\n{v_col.shape}\")\nprint(f\"Vector Fila (v_col.T):\\n{v_col.T.shape}\")\n\nprint(\"\\n--- 2. MATRICES Y PROPIEDAD (AB)^T ---\")\n# A: Matriz de datos (2 muestras, 3 variables)\nA = torch.tensor([[1., 2., 3.], \n                  [4., 5., 6.]]) # Shape (2, 3)\n\n# B: Matriz de transformaci\u00f3n (3 entradas, 2 salidas)\nB = torch.tensor([[0.1, 0.2], \n                  [0.3, 0.4], \n                  [0.5, 0.6]])   # Shape (3, 2)\n\n# Operaci\u00f3n: Transpuesta del producto\nlhs = torch.matmul(A, B).T   # (AB)^T\n\n# Verificaci\u00f3n de la propiedad te\u00f3rica\n# INCORRECTO: A.T @ B.T (Error de dimensiones o resultado err\u00f3neo)\n# CORRECTO: B.T @ A.T (Invirtiendo el orden)\nrhs = torch.matmul(B.T, A.T) \n\nprint(f\"Forma de (AB).T: {lhs.shape}\")\nprint(f\"\u00bfEs igual a B.T @ A.T?: {torch.allclose(lhs, rhs)}\")\n</code></pre> <pre><code>--- 1. EL 'ENGA\u00d1O' DE LOS VECTORES 1D ---\nVector plano: torch.Size([3])\nTranspuesta v.T: torch.Size([3]) (\u00a1No cambia!)\nVector Columna:\ntorch.Size([3, 1])\nVector Fila (v\\_col.T):  % &lt;--- AQU\u00cd ESTABA EL ERROR (agregu\u00e9 \\)\ntorch.Size([1, 3])\n\n--- 2. MATRICES Y PROPIEDAD (AB)\\^T ---\nForma de (AB).T: torch.Size([2, 2])\n\u00bfEs igual a B.T @ A.T?: True\n</code></pre>"},{"location":"estructura-datos.html#transposicion-en-tensores-permutacion","title":"Transposici\u00f3n en Tensores (Permutaci\u00f3n)","text":"<p>Para tensores de rango \\(N \\ge 3\\), la noci\u00f3n de transposici\u00f3n se generaliza a la permutaci\u00f3n de ejes. No existe una \u00fanica \"transpuesta\", sino m\u00faltiples reordenamientos posibles de las dimensiones.</p> <p>Dado un tensor \\(\\mathcal{T} \\in \\mathbb{R}^{d_1 \\times d_2 \\times d_3}\\), con entradas \\(t_{ijk}\\) donde \\(i\\) es el \u00edndice del primer eje, \\(j\\) del segundo y \\(k\\) del tercero.</p> <p>Una permutaci\u00f3n com\u00fan (por ejemplo, invertir el orden de los ejes) genera un nuevo tensor \\(\\mathcal{T}' \\in \\mathbb{R}^{d_3 \\times d_2 \\times d_1}\\) tal que:</p> \\[\\mathcal{T}'_{kji} = \\mathcal{T}_{ijk}\\] <p>En la pr\u00e1ctica de visi\u00f3n computacional, la operaci\u00f3n m\u00e1s frecuente es intercambiar el eje de canales (C) para moverlo del principio al final:</p> <p>Definici\u00f3n pr\u00e1ctica (Cambio de Formato): Sea un tensor de imagen \\(\\mathbf{I} \\in \\mathbb{R}^{C \\times H \\times W}\\) (formato PyTorch). Su versi\u00f3n permutada \\(\\mathbf{I}_{perm} \\in \\mathbb{R}^{H \\times W \\times C}\\) (formato Matplotlib/OpenCV) se define reordenando los \u00edndices \\((c, h, w) \\to (h, w, c)\\):</p> \\[\\mathbf{I} =  \\left[ \\text{Canales}, \\text{Alto}, \\text{Ancho} \\right] \\xrightarrow{\\text{permute}(1, 2, 0)} \\mathbf{I}_{perm} =  \\left[ \\text{Alto}, \\text{Ancho}, \\text{Canales} \\right]\\] <pre><code>import torch\n\n# Tensor 3D: Una imagen RGB simulada (3 canales, 4 alto, 4 ancho)\n# Formato PyTorch: (C, H, W)\nimagen_torch = torch.rand(3, 4, 4)\nprint(f\"Forma original (C, H, W): {imagen_torch.shape}\")\n\n# PROBLEMA: Las librer\u00edas de visualizaci\u00f3n (matplotlib) esperan (H, W, C)\n# SOLUCI\u00d3N: Permutar los ejes.\n# \u00cdndice 0-&gt;2 (Canales al final)\n# \u00cdndice 1-&gt;0 (Alto al principio)\n# \u00cdndice 2-&gt;1 (Ancho al medio)\nimagen_plot = imagen_torch.permute(1, 2, 0)\n\nprint(f\"Forma permutada (H, W, C): {imagen_plot.shape}\")\n\n# Cuidado: .T (transpuesta simple) en PyTorch no siempre funciona intuitivamente en tensores &gt; 2D\n# Es preferible ser expl\u00edcito con .permute()\n</code></pre> <pre><code>Forma original (C, H, W): torch.Size([3, 4, 4])\nForma permutada (H, W, C): torch.Size([4, 4, 3])\n</code></pre>"},{"location":"estructura-datos.html#igualdad-de-vectores","title":"Igualdad de vectores","text":"<p>Dos vectores \\(\\mathbf{x}, \\mathbf{y} \\in \\mathbb{R}^n\\) se consideran iguales si satisfacen simult\u00e1neamente dos condiciones:</p> <ol> <li> <p>Pertenecen al mismo espacio vectorial (tienen la misma dimensi\u00f3n \\(n\\)).</p> </li> <li> <p>Sus componentes correspondientes son id\u00e9nticas en valor y posici\u00f3n.</p> </li> </ol> <p>Formalmente:</p> \\[\\mathbf{x} = \\mathbf{y} \\quad \\Longleftrightarrow \\quad x_i = y_i \\quad \\text{para todo } i = 1, \\dots, n.\\]"},{"location":"estructura-datos.html#interpretacion-agronomica","title":"Interpretaci\u00f3n Agron\u00f3mica","text":"<p>La igualdad vectorial implica una r\u00e9plica exacta de condiciones. Por ejemplo, dos lotes de cultivo tienen un manejo nutricional id\u00e9ntico solo si sus vectores de fertilizaci\u00f3n \\(\\mathbf{f}_A = (N, P, K, \\text{Micro})\\) y \\(\\mathbf{f}_B\\) son iguales componente a componente. Si \\(N_A = N_B\\) pero \\(K_A \\neq K_B\\), entonces \\(\\mathbf{f}_A \\neq \\mathbf{f}_B\\), lo que significa que los tratamientos son agron\u00f3micamente distintos.</p> <p>Administraci\u00f3n y Finanzas: Conciliaci\u00f3n</p> <p>La igualdad vectorial es la base de la auditor\u00eda. Si definimos un vector de presupuesto planificado \\(\\mathbf{p} \\in \\mathbb{R}^3\\) y un vector de ejecuci\u00f3n real \\(\\mathbf{e} \\in \\mathbb{R}^3\\) para tres departamentos (Ventas, I+D, Operaciones):</p> \\[\\mathbf{p} = \\begin{pmatrix} 100 \\\\ 50 \\\\ 80 \\end{pmatrix}, \\quad  \\mathbf{e} = \\begin{pmatrix} 100 \\\\ 50 \\\\ 80 \\end{pmatrix}\\] <p>La condici\u00f3n \\(\\mathbf{p} = \\mathbf{e}\\) indica un cumplimiento presupuestario perfecto (varianza cero). Si \\(\\mathbf{p} \\neq \\mathbf{e}\\), la diferencia \\(\\mathbf{d} = \\mathbf{p} - \\mathbf{e}\\) generar\u00e1 un vector de desviaciones no nulo que debe ser justificado.</p>"},{"location":"estructura-datos.html#igualdad-de-matrices","title":"Igualdad de matrices","text":"<p>Dos matrices \\(\\mathbf{A}, \\mathbf{B} \\in \\mathbb{R}^{m \\times n}\\) se consideran iguales si y solo si satisfacen simult\u00e1neamente dos condiciones:</p> <ol> <li> <p>Tienen las mismas dimensiones (igual n\u00famero de filas \\(m\\) y columnas \\(n\\)).</p> </li> <li> <p>Sus entradas correspondientes son id\u00e9nticas en valor y posici\u00f3n.</p> </li> </ol> <p>Formalmente:</p> \\[\\mathbf{A} = \\mathbf{B} \\quad \\Longleftrightarrow \\quad A_{ij} = B_{ij} \\quad \\text{para todo } i = 1, \\dots, m; \\; j = 1, \\dots, n.\\]"},{"location":"estructura-datos.html#interpretacion-ambiental-deteccion-de-cambios","title":"Interpretaci\u00f3n Ambiental: Detecci\u00f3n de Cambios","text":"<p>En monitoreo satelital, una imagen espectral se representa como una matriz num\u00e9rica donde cada entrada corresponde a un p\u00edxel. Sea \\(\\mathbf{M}_{2020}\\) la matriz de \u00edndices de vegetaci\u00f3n (NDVI) de una reserva forestal en 2020 y \\(\\mathbf{M}_{2024}\\) la del a\u00f1o actual. La igualdad \\(\\mathbf{M}_{2020} = \\mathbf{M}_{2024}\\) indicar\u00eda una conservaci\u00f3n absoluta del ecosistema. En la pr\u00e1ctica, los cient\u00edficos buscan la matriz diferencia \\(\\mathbf{D} = \\mathbf{M}_{2024} - \\mathbf{M}_{2020}\\); si una entrada \\(D_{ij}\\) es significativamente distinta de cero (negativa), alerta sobre una posible deforestaci\u00f3n en esa coordenada espec\u00edfica.</p> <p>Mecatr\u00f3nica: Control de Robots</p> <p>En rob\u00f3tica, la posici\u00f3n y orientaci\u00f3n de un brazo manipulador se describen mediante matrices de transformaci\u00f3n homog\u00e9nea de \\(4 \\times 4\\). Sea \\(\\mathbf{T}_{\\text{obj}}\\) la matriz que representa la pose deseada (target) del efector final (la pinza) y \\(\\mathbf{T}_{\\text{act}}\\) la pose actual le\u00edda por los sensores:</p> \\[\\mathbf{T}_{\\text{obj}} =  \\begin{pmatrix}  1 &amp; 0 &amp; 0 &amp; 10 \\\\  0 &amp; 1 &amp; 0 &amp; 5 \\\\  0 &amp; 0 &amp; 1 &amp; 20 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}, \\quad \\mathbf{T}_{\\text{act}} =  \\begin{pmatrix}  1 &amp; 0 &amp; 0 &amp; 9.8 \\\\  0 &amp; 1 &amp; 0 &amp; 5 \\\\  0 &amp; 0 &amp; 1 &amp; 20 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] <p>El sistema de control verifica la igualdad. Como \\(T_{14}\\) (posici\u00f3n en \\(x\\)) es \\(10\\) en la deseada y \\(9.8\\) en la actual, \\(\\mathbf{T}_{\\text{obj}} \\neq \\mathbf{T}_{\\text{act}}\\). Esto genera una se\u00f1al de error que activa los motores para corregir esa diferencia de \\(0.2\\) unidades.</p>"},{"location":"estructura-datos.html#generalizacion-a-tensores","title":"Generalizaci\u00f3n a Tensores","text":"<p>El concepto de igualdad se extiende naturalmente a arreglos multidimensionales de orden superior, conocidos como tensores. Sean \\(\\mathcal{A}\\) y \\(\\mathcal{B}\\) dos tensores de orden 3 (por ejemplo, de dimensiones \\(m \\times n \\times p\\)). Estos se consideran iguales solo si coinciden en cada voxel o celda c\u00fabica:</p> \\[\\mathcal{A} = \\mathbf{B} \\quad \\Longleftrightarrow \\quad A_{ijk} = B_{ijk} \\quad \\forall i,j,k.\\]"},{"location":"estructura-datos.html#ejemplo-imagenes-rgb","title":"Ejemplo: Im\u00e1genes RGB","text":"<p>Una imagen digital a color se representa como un tensor de \\(\\text{Alto} \\times \\text{Ancho} \\times 3\\) (Canales: Rojo, Verde, Azul). Si tenemos una imagen original \\(\\mathcal{I}_{\\text{orig}}\\) y una copia transmitida por internet \\(\\mathcal{I}_{\\text{copia}}\\), la igualdad \\(\\mathcal{I}_{\\text{orig}} = \\mathcal{I}_{\\text{copia}}\\) asegura la integridad de los datos. Basta con que un solo p\u00edxel cambie levemente su tono en el canal azul para que \\(\\mathcal{I}_{\\text{orig}} \\neq \\mathcal{I}_{\\text{copia}}\\), lo cual en criptograf\u00eda o esteganograf\u00eda podr\u00eda indicar que la imagen fue alterada.</p>"},{"location":"estructura-datos.html#igualdad-computacional-el-desafio-del-punto-flotante","title":"Igualdad Computacional: El Desaf\u00edo del Punto Flotante","text":"<p>En la pr\u00e1ctica profesional de la Ciencia de Datos, rara vez verificamos la igualdad matem\u00e1tica estricta (\\(\\mathbf{A} = \\mathbf{B}\\)). Esto se debe a que las computadoras utilizan el est\u00e1ndar IEEE 754 para representar n\u00fameros decimales (punto flotante), donde operaciones simples introducen errores infinitesimales de redondeo en los bits menos significativos.</p> <p>Para abordar la comparaci\u00f3n de tensores, es fundamental distinguir dos enfoques y una soluci\u00f3n t\u00e9cnica:</p> <ol> <li> <p>Comparaci\u00f3n Element-wise (Elemento a elemento): Genera una matriz de valores booleanos del mismo tama\u00f1o que las originales. Es \u00fatil para crear \"m\u00e1scaras\" y detectar d\u00f3nde difieren los datos.</p> </li> <li> <p>Comparaci\u00f3n Estricta: Verifica si la estructura es id\u00e9ntica en su totalidad. Falla frecuentemente con n\u00fameros decimales (floats).</p> </li> <li> <p>Comparaci\u00f3n con Tolerancia (La Soluci\u00f3n): Sustituye la igualdad estricta por la proximidad dentro de un umbral \\(\\epsilon\\).</p> </li> </ol> <p>Matem\u00e1ticamente, definimos la igualdad computacional como:</p> \\[\\mathbf{A} \\approx \\mathbf{B} \\iff |a_{ij} - b_{ij}| &lt; \\epsilon, \\quad \\forall i,j\\] <p>Donde \\(\\epsilon\\) (epsilon) suele ser un valor muy peque\u00f1o (ej. \\(10^{-5}\\) o \\(10^{-8}\\)).</p> <pre><code>import torch\n\nprint(\"--- 1. ELEMENT-WISE VS ESTRUCTURA ---\")\nA = torch.tensor([1.0, 2.0])\nB = torch.tensor([1.0, 5.0]) # El segundo elemento difiere\n\n# Comparaci\u00f3n elemento a elemento (Genera m\u00e1scara)\nprint(f\"M\u00e1scara: {A == B}\") \n# Salida esperada: [True, False]\n\nprint(\"\\n--- 2. EL PROBLEMA DEL PUNTO FLOTANTE ---\")\n# Matem\u00e1ticamente: (Ra\u00edz de 2) al cuadrado = 2\nraiz = torch.sqrt(torch.tensor(2.0))\ncalculado = raiz * raiz\nteorico   = torch.tensor(2.0)\n\n# Mostramos con 10 decimales para revelar el \"error fantasma\"\nprint(f\"Valor Te\u00f3rico:   {teorico.item():.10f}\")\nprint(f\"Valor Calculado: {calculado.item():.10f}\")\n\n# Intento 1: Igualdad Estricta (==)\n# Falla porque 2.0000000000 != 2.0000002384\nprint(f\"\u00bfIgualdad Estricta? {calculado == teorico}\")\n\nprint(\"\\n--- 3. SOLUCI\u00d3N: TOLERANCIA (ALLCLOSE) ---\")\n# Verificamos si la diferencia es despreciable\n# atol = tolerancia absoluta\nes_cercano = torch.allclose(calculado, teorico, atol=1e-05)\nprint(f\"\u00bfIgualdad con tolerancia (allclose)? {es_cercano}\")\n</code></pre> <pre><code>--- 1. ELEMENT-WISE VS ESTRUCTURA ---\nM\u00e1scara: tensor([ True, False])\n\n--- 2. EL PROBLEMA DEL PUNTO FLOTANTE ---\nValor Te\u00f3rico:   2.0000000000\nValor Calculado: 2.0000002384\n\u00bfIgualdad Estricta? tensor(False)\n\n--- 3. SOLUCI\u00d3N: TOLERANCIA (ALLCLOSE) ---\n\u00bfIgualdad con tolerancia (allclose)? True\n</code></pre>"},{"location":"estructura-datos.html#norma-euclidiana-magnitud-y-direccion","title":"Norma euclidiana (magnitud) y direcci\u00f3n","text":"<p>La norma euclidiana (tambi\u00e9n llamada longitud o m\u00f3dulo) de un vector \\(\\mathbf{x} = (x_1, \\dots, x_n)^\\top \\in \\mathbb{R}^n\\) se define como la ra\u00edz cuadrada de la suma de sus componentes al cuadrado:</p> \\[\\lVert \\mathbf{x} \\rVert = \\sqrt{x_1^2 + x_2^2 + \\cdots + x_n^2} .\\] <p>Esta medida generaliza el concepto de distancia desde el origen hasta el punto \\(\\mathbf{x}\\). En ciencia de datos, es fundamental para normalizar variables (escalar datos), calcular el error cuadr\u00e1tico medio o evaluar la \\\"fuerza\\\" de una se\u00f1al.</p>"},{"location":"estructura-datos.html#interpretacion-en-el-plano-mathbbr2","title":"Interpretaci\u00f3n en el plano (\\(\\mathbb{R}^2\\))","text":"<p>En dos dimensiones, un vector \\(\\mathbf{x} = (x_1, x_2)^\\top\\) se representa geom\u00e9tricamente como una flecha. Sus propiedades fundamentales son:</p> <ol> <li> <p>Magnitud: La longitud de la flecha, dada por Pit\u00e1goras: \\(\\lVert \\mathbf{x} \\rVert = \\sqrt{x_1^2 + x_2^2}\\).</p> </li> <li> <p>Direcci\u00f3n: El \u00e1ngulo \\(\\theta\\) respecto al eje horizontal, calculado como \\(\\theta = \\arctan(x_2 / x_1)\\).</p> </li> </ol> <p>La Figura 1 ilustra c\u00f3mo las componentes definen tanto la posici\u00f3n final como la orientaci\u00f3n del vector.</p> Representaci\u00f3n geom\u00e9trica: la norma es la longitud de la hipotenusa y \u03b8 determina la orientaci\u00f3n. <p>Ejemplo Administrativo: Presupuesto Vectorial</p> <p>Considere una propuesta presupuestaria \\(\\mathbf{p} \\in \\mathbb{R}^2\\) (en millones de pesos) asignada a Infraestructura y Capacitaci\u00f3n:</p> \\[\\mathbf{p} = \\begin{pmatrix} 4 \\\\ 3 \\end{pmatrix}\\] <ul> <li> <p>Magnitud (Esfuerzo Total): \\(\\lVert \\mathbf{p} \\rVert = \\sqrt{4^2 + 3^2} = \\sqrt{25} = 5\\). El tama\u00f1o total de la inversi\u00f3n es 5 millones.</p> </li> <li> <p>Direcci\u00f3n (Prioridad Estrat\u00e9gica): El \u00e1ngulo respecto a infraestructura es \\(\\theta = \\arctan(3/4) \\approx 36{,}9^\\circ\\).</p> <ul> <li> <p>Si \\(\\theta \\to 0^\\circ\\), la prioridad es 100% Infraestructura.</p> </li> <li> <p>Si \\(\\theta \\to 90^\\circ\\), la prioridad es 100% Capacitaci\u00f3n.</p> </li> <li> <p>Con \\(36{,}9^\\circ\\), existe un balance inclinado hacia la infraestructura.</p> </li> </ul> </li> </ul>"},{"location":"estructura-datos.html#orientacion-en-el-espacio-mathbbr3-cosenos-directores","title":"Orientaci\u00f3n en el espacio (\\(\\mathbb{R}^3\\)): Cosenos directores","text":"<p>En tres dimensiones, un solo \u00e1ngulo no basta para definir la direcci\u00f3n. Para un vector \\(\\mathbf{x} = (x_1, x_2, x_3)^\\top\\), utilizamos los cosenos directores, que son los cosenos de los \u00e1ngulos \\((\\alpha, \\beta, \\gamma)\\) que forma el vector con cada uno de los ejes coordenados (\\(x, y, z\\) respectivamente):</p> \\[\\cos(\\alpha) = \\frac{x_1}{\\lVert \\mathbf{x} \\rVert}, \\quad \\cos(\\beta)  = \\frac{x_2}{\\lVert \\mathbf{x} \\rVert}, \\quad \\cos(\\gamma) = \\frac{x_3}{\\lVert \\mathbf{x} \\rVert}.\\] <p>Estos valores oscilan entre -1 y 1. Un valor cercano a 1 indica que el vector est\u00e1 muy alineado con ese eje espec\u00edfico, dominando el comportamiento de la variable.</p> <p>Ejemplo Ambiental: Calidad del Aire</p> <p>Analicemos el vector de contaminantes (en \\(\\mu\\text{g/m}^3\\)) de una estaci\u00f3n urbana:</p> \\[\\mathbf{a} =  \\begin{pmatrix} \\mathrm{PM}_{10} \\\\ \\mathrm{NO}_2 \\\\ \\mathrm{O}_3 \\end{pmatrix} = \\begin{pmatrix} 40 \\\\ 30 \\\\ 50 \\end{pmatrix}\\] <ol> <li> <p>Magnitud (Intensidad de Contaminaci\u00f3n):</p> \\[\\lVert \\mathbf{a} \\rVert = \\sqrt{40^2 + 30^2 + 50^2} = \\sqrt{5000} \\approx 70{,}71.\\] </li> <li> <p>An\u00e1lisis de Dominancia (Cosenos Directores):</p> \\[\\cos(\\gamma)_{\\mathrm{O}_3} = \\frac{50}{70{,}71} \\approx \\mathbf{0{,}707}, \\quad     \\cos(\\alpha)_{\\mathrm{PM}_{10}} \\approx 0{,}566.\\] <p>La componente de Ozono (\\(\\mathrm{O}_3\\)) tiene el coseno director m\u00e1s alto (\\(0{,}707\\)), lo que indica que es el contaminante dominante en este perfil. Esto sugiere un problema de tipo fotoqu\u00edmico (reacci\u00f3n a la luz solar) m\u00e1s que de emisiones primarias de combusti\u00f3n (\\(\\mathrm{NO}_2\\)), permitiendo a las autoridades decidir si restringen el tr\u00e1fico o la industria.</p> </li> </ol>"},{"location":"estructura-datos.html#implementacion-computacional-normas-y-normalizacion","title":"Implementaci\u00f3n Computacional: Normas y Normalizaci\u00f3n","text":"<p>En el ecosistema de Python (NumPy y PyTorch), el c\u00e1lculo de la magnitud y la direcci\u00f3n est\u00e1 altamente optimizado. No es necesario iterar manualmente sobre los elementos sumando cuadrados; las librer\u00edas utilizan rutinas de bajo nivel (BLAS/LAPACK) para hacerlo instant\u00e1neamente.</p>"},{"location":"estructura-datos.html#calculo-de-la-norma-l_2","title":"C\u00e1lculo de la Norma (\\(L_2\\))","text":"<p>Aunque la f\u00f3rmula es \\(\\sqrt{\\sum x_i^2}\\), en c\u00f3digo utilizamos funciones dedicadas como <code>torch.norm</code> o <code>numpy.linalg.norm</code>. Esto previene errores de desbordamiento num\u00e9rico (overflow) cuando los n\u00fameros son muy grandes.</p> <pre><code>import torch\n\n# Ejemplo Administrativo: Presupuesto [Infra, Capa]\np = torch.tensor([4.0, 3.0])\n\n# FORMA 1: Manual (Solo con fines educativos)\n# Paso a paso: Cuadrado -&gt; Suma -&gt; Ra\u00edz\nnorma_manual = torch.sqrt(torch.sum(p**2))\n\n# FORMA 2: Profesional (La que usar\u00e1s siempre)\n# Es m\u00e1s r\u00e1pida y num\u00e9ricamente estable\nnorma_pro = torch.norm(p)\n\nprint(f\"Vector p: {p}\")\nprint(f\"Norma Manual: {norma_manual.item()}\") # 5.0\nprint(f\"Norma Pro:    {norma_pro.item()}\")    # 5.0\n</code></pre>"},{"location":"estructura-datos.html#direccion-y-normalizacion","title":"Direcci\u00f3n y Normalizaci\u00f3n","text":"<p>Aqu\u00ed distinguimos entre 2D y \\(N\\)-Dimensiones:</p> <ol> <li> <p>En 2D (\u00c1ngulos): No usamos \\(\\arctan(y/x)\\) porque falla si \\(x=0\\). Usamos la funci\u00f3n especial <code>atan2(y, x)</code>, que maneja todos los cuadrantes y la divisi\u00f3n por cero autom\u00e1ticamente.</p> </li> <li> <p>En ND (Cosenos Directores = Normalizaci\u00f3n): Calcular los cosenos directores equivale a convertir el vector en un Vector Unitario (longitud 1). Esta operaci\u00f3n se llama Normalizaci\u00f3n L2 y es vital en redes neuronales.</p> </li> </ol> \\[\\hat{\\mathbf{x}} = \\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert} = (\\cos \\alpha, \\cos \\beta, \\cos \\gamma)^\\top\\] <pre><code>import torch\nimport math\n\nprint(\"--- 1. DIRECCI\u00d3N EN 2D (PRESUPUESTO) ---\")\np = torch.tensor([4.0, 3.0]) # x=4, y=3\n\n# Usamos atan2(y, x). Nota: El orden es (y, x)\ntheta_rad = torch.atan2(p[1], p[0])\n\n# Convertimos radianes a grados para humanos\ntheta_deg = torch.rad2deg(theta_rad)\n\nprint(f\"\u00c1ngulo (theta): {theta_deg.item():.1f} grados\")\n\n\nprint(\"\\n--- 2. DIRECCI\u00d3N EN 3D (CALIDAD AIRE) ---\")\n# Vector: [PM10, NO2, O3]\na = torch.tensor([40.0, 30.0, 50.0])\n\n# Calculamos la norma\nmagnitud = torch.norm(a)\n\n# Cosenos Directores: Dividimos el vector por su magnitud\n# Esto crea un 'Vector Unitario' (Unit Vector)\ncosenos_directores = a / magnitud\n\nprint(f\"Magnitud total: {magnitud:.2f}\")\nprint(f\"Cosenos Directores (Direcci\u00f3n):\\n{cosenos_directores}\")\n\n# Verificaci\u00f3n: La norma de los cosenos directores siempre es 1\nprint(f\"Comprobaci\u00f3n (Norma del unitario): {torch.norm(cosenos_directores):.1f}\")\n</code></pre> <pre><code>--- 1. DIRECCI\u00d3N EN 2D (PRESUPUESTO) ---\n\u00c1ngulo (theta): 36.9 grados\n\n--- 2. DIRECCI\u00d3N EN 3D (CALIDAD AIRE) ---\nMagnitud total: 70.71\nCosenos Directores (Direcci\u00f3n):\ntensor([0.5657, 0.4243, 0.7071])\nComprobaci\u00f3n (Norma del unitario): 1.0\n</code></pre>"},{"location":"estructura-datos.html#ejercicios-propuestos","title":"Ejercicios propuestos","text":"<ol> <li> <p>Clasificaci\u00f3n de Estructuras (Rangos): Identifique el rango (0, 1, 2 o \\(\\ge 3\\)) y la dimensi\u00f3n matem\u00e1tica aproximada (ej. \\(\\mathbb{R}^n\\)) de los siguientes objetos de datos agroambientales:</p> <ol> <li> <p>La concentraci\u00f3n de nitratos en una muestra de suelo (un solo valor num\u00e9rico).</p> </li> <li> <p>El perfil de temperatura de un silo medido a 10 alturas diferentes.</p> </li> <li> <p>Una fotograf\u00eda a\u00e9rea de un cultivo en escala de grises de \\(1024 \\times 768\\) p\u00edxeles.</p> </li> <li> <p>Un conjunto de datos multitemporal que contiene 5 bandas espectrales, para una imagen de \\(500 \\times 500\\) p\u00edxeles, tomada durante 12 meses consecutivos.</p> </li> </ol> </li> <li> <p>Interpretaci\u00f3n de la Transpuesta: Sea \\(\\mathbf{D} \\in \\mathbb{R}^{100 \\times 5}\\) una matriz de datos donde las filas (\\(i=1\\dots100\\)) representan plantas de ma\u00edz individuales y las columnas (\\(j=1\\dots5\\)) representan variables medidas (Altura, Grosor de tallo, N\u00famero de hojas, Clorofila, Rendimiento).</p> <ol> <li> <p>\u00bfCu\u00e1les son las dimensiones de la matriz transpuesta \\(\\mathbf{D}^\\top\\)?</p> </li> <li> <p>En la matriz \\(\\mathbf{D}^\\top\\), \u00bfqu\u00e9 representa ahora una fila? \u00bfY una columna?</p> </li> <li> <p>\u00bfPor qu\u00e9 podr\u00eda ser \u00fatil calcular la media de las filas de \\(\\mathbf{D}^\\top\\) para un an\u00e1lisis estad\u00edstico?</p> </li> </ol> </li> <li> <p>Verificaci\u00f3n de Igualdad: Dadas las matrices:</p> \\[\\mathbf{A} = \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix}, \\quad     \\mathbf{B} = \\begin{pmatrix} 1 &amp; 2 &amp; 0 \\\\ 3 &amp; 4 &amp; 0 \\end{pmatrix}, \\quad     \\mathbf{C} = \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4.00001 \\end{pmatrix}\\] <ol> <li> <p>\u00bfEs \\(\\mathbf{A} = \\mathbf{B}\\)? Justifique su respuesta bas\u00e1ndose en las dimensiones.</p> </li> <li> <p>\u00bfEs \\(\\mathbf{A} = \\mathbf{C}\\) en t\u00e9rminos matem\u00e1ticos estrictos?</p> </li> <li> <p>Si \\(\\mathbf{C}\\) proviene de un sensor digital ruidoso, \u00bfconsiderar\u00eda estas matrices iguales en un contexto aplicado?</p> </li> </ol> </li> <li> <p>Laboratorio de Python (NumPy): Escriba un script en Python que realice lo siguiente:</p> <ul> <li> <p>Cree un vector \\(\\mathbf{v}\\) con los valores \\([0, 10, 20, 30]\\) (representando lecturas ideales de un sensor).</p> </li> <li> <p>Simule un vector de lectura real \\(\\mathbf{v}_{ruido}\\) sumando un peque\u00f1o valor aleatorio (ej. \\(0.005\\)) a cada componente.</p> </li> <li> <p>Intente verificar la igualdad con el operador standard <code>==</code> y comente el resultado.</p> </li> <li> <p>Verifique la igualdad correctamente utilizando <code>np.allclose</code> con una tolerancia adecuada.</p> </li> </ul> </li> <li> <p>Agron\u00f3mico (An\u00e1lisis de Suelos - Transpuesta): Un laboratorio entrega los resultados de an\u00e1lisis de suelo de 3 lotes diferentes en una matriz \\(\\mathbf{S} \\in \\mathbb{R}^{3 \\times 4}\\), donde las filas son los Lotes (A, B, C) y las columnas son los par\u00e1metros (pH, M.O., P, K).</p> \\[\\mathbf{S} =      \\begin{pmatrix}     5.5 &amp; 2.1 &amp; 15 &amp; 0.4 \\\\     6.2 &amp; 3.5 &amp; 20 &amp; 0.6 \\\\     5.8 &amp; 2.8 &amp; 12 &amp; 0.5     \\end{pmatrix}\\] <ol> <li> <p>Escriba expl\u00edcitamente la matriz transpuesta \\(\\mathbf{S}^\\top\\).</p> </li> <li> <p>Interprete el significado de la segunda fila de la matriz transpuesta. \u00bfQu\u00e9 informaci\u00f3n agrupa?</p> </li> </ol> </li> <li> <p>Agr\u00edcola (Monitoreo de Cosecha - Igualdad): Se tiene un vector de rendimiento estimado \\(\\mathbf{r}_{est} = [4.5, 5.0, 4.2]^\\top\\) (ton/ha) para tres variedades de ma\u00edz. Al finalizar la cosecha, el vector real fue \\(\\mathbf{r}_{real} = [4.48, 5.01, 3.8]^\\top\\).</p> <ol> <li> <p>Si definimos una tolerancia de error de \\(\\pm 0.05\\) ton/ha, \u00bfpara cu\u00e1les variedades se cumple que \\(\\mathbf{r}_{est} \\approx \\mathbf{r}_{real}\\)?</p> </li> <li> <p>\u00bfC\u00f3mo expresar\u00eda esta comparaci\u00f3n utilizando la resta vectorial \\(\\mathbf{d} = \\mathbf{r}_{est} - \\mathbf{r}_{real}\\)?</p> </li> </ol> </li> <li> <p>Agroindustrial (Control de Calidad - Matrices): Una planta procesadora de jugos produce lotes de 3 sabores (Naranja, Mango, Mora). La matriz \\(\\mathbf{M}_{std}\\) define la formulaci\u00f3n est\u00e1ndar (kg de fruta, litros de agua, kg de az\u00facar) y \\(\\mathbf{M}_{lote}\\) es la mezcla actual.</p> \\[\\mathbf{M}_{std} =      \\begin{pmatrix}     100 &amp; 50 &amp; 5 \\\\     120 &amp; 40 &amp; 6 \\\\     90 &amp; 60 &amp; 4     \\end{pmatrix}\\] <p>Si el sistema de control detecta que \\(\\mathbf{M}_{lote} \\neq \\mathbf{M}_{std}\\), explique qu\u00e9 consecuencias f\u00edsicas tiene esto para el producto final si la diferencia ocurre en la posici\u00f3n \\((2,3)\\) (Fila 2, Columna 3).</p> </li> <li> <p>Ambiental (Datos Clim\u00e1ticos - Tensores): Una estaci\u00f3n meteorol\u00f3gica registra datos utilizando un tensor \\(\\mathcal{C}\\) de dimensiones \\(365 \\times 24 \\times 3\\).</p> <ul> <li> <p>Dimensi\u00f3n 1: D\u00edas del a\u00f1o (\\(1 \\dots 365\\)).</p> </li> <li> <p>Dimensi\u00f3n 2: Horas del d\u00eda (\\(0 \\dots 23\\)).</p> </li> <li> <p>Dimensi\u00f3n 3: Variables (Temperatura, Humedad, Radiaci\u00f3n Solar).</p> </li> <li> <p>\u00bfQu\u00e9 representa una \\\"rebanada\\\" (slice) del tensor si fijamos la primera dimensi\u00f3n (ej. d\u00eda 100) y tomamos todos los datos restantes (\\(100, :, :\\))?</p> </li> <li> <p>Si extraemos el vector \\(\\mathbf{v} = \\mathcal{C}(:, 12, 0)\\), \u00bfqu\u00e9 serie de tiempo estamos analizando?</p> </li> </ul> </li> <li> <p>Administrativo (Inventarios - Dimensi\u00f3n): Una cooperativa gestiona 2 bodegas. La Bodega Norte tiene un inventario representado por el vector \\(\\mathbf{b}_N \\in \\mathbb{R}^{5}\\) (5 tipos de insumos). La Bodega Sur maneja 6 tipos de insumos, representada por \\(\\mathbf{b}_S \\in \\mathbb{R}^{6}\\).</p> <ol> <li> <p>\u00bfEs matem\u00e1ticamente posible realizar la operaci\u00f3n de comparaci\u00f3n \\(\\mathbf{b}_N = \\mathbf{b}_S\\)? \u00bfPor qu\u00e9?</p> </li> <li> <p>Desde el punto de vista administrativo, \u00bfqu\u00e9 paso previo (padding o relleno) deber\u00eda realizarse para poder consolidar ambos inventarios en una sola matriz?</p> </li> </ol> </li> <li> <p>Mecatr\u00f3nica (Visi\u00f3n Artificial para Pick-and-Place): Un brazo rob\u00f3tico utiliza una c\u00e1mara de baja resoluci\u00f3n para identificar piezas defectuosas en una banda transportadora. La imagen ideal de una pieza correcta est\u00e1 representada por la matriz binaria \\(\\mathbf{P}_{ideal}\\) (donde 1 es metal y 0 es fondo). La c\u00e1mara captura una imagen \\(\\mathbf{P}_{cam}\\) de la pieza que pasa actualmente.</p> \\[\\mathbf{P}_{ideal} =      \\begin{pmatrix}     0 &amp; 1 &amp; 1 &amp; 0 \\\\     0 &amp; 1 &amp; 1 &amp; 0 \\\\     0 &amp; 1 &amp; 1 &amp; 0 \\\\     0 &amp; 0 &amp; 0 &amp; 0     \\end{pmatrix}     \\quad , \\quad     \\mathbf{P}_{cam} =      \\begin{pmatrix}     0 &amp; 0 &amp; 0 &amp; 0 \\\\     1 &amp; 1 &amp; 1 &amp; 0 \\\\     1 &amp; 1 &amp; 1 &amp; 0 \\\\     0 &amp; 0 &amp; 0 &amp; 0     \\end{pmatrix}\\] <ol> <li> <p>Pre-procesamiento (Transposici\u00f3n): El ingeniero nota que la c\u00e1mara fue montada girada \\(90^\\circ\\) respecto al modelo ideal, o la pieza lleg\u00f3 rotada. Calcule \\(\\mathbf{P}_{ideal}^\\top\\). \u00bfSe cumple que \\(\\mathbf{P}_{ideal}^\\top = \\mathbf{P}_{cam}\\)?</p> </li> <li> <p>Detecci\u00f3n de Defectos (Matrices Diferencia): Suponga ahora que llega una nueva pieza \\(\\mathbf{P}_{nueva}\\). Para encontrar defectos, el robot calcula la \\\"matriz de error\\\" \\(\\mathbf{E} = \\mathbf{P}_{ideal} - \\mathbf{P}_{nueva}\\). Si el resultado es:</p> \\[\\mathbf{E} =          \\begin{pmatrix}         0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0         \\end{pmatrix}\\] <p>Interprete el resultado: \u00bfLe falta material a la pieza o le sobra? \u00bfEn qu\u00e9 coordenada espec\u00edfica \\((i, j)\\) est\u00e1 el defecto f\u00edsico?</p> </li> <li> <p>L\u00f3gica de Control: En un script de Python para el controlador del robot, \u00bfpor qu\u00e9 la siguiente condici\u00f3n l\u00f3gica es peligrosa para la producci\u00f3n?</p> <pre><code>if imagen_camara != imagen_ideal:\n    detener_linea_produccion()\n</code></pre> <p>Pista: Piense en el ruido el\u00e9ctrico de los sensores o cambios de iluminaci\u00f3n.</p> </li> </ol> </li> </ol>"},{"location":"estructura-datos.html#ejercicios-de-integracion-magnitud-vs-direccion","title":"Ejercicios de Integraci\u00f3n: Magnitud vs. Direcci\u00f3n","text":"<p>Estos ejercicios est\u00e1n dise\u00f1ados para distinguir cu\u00e1ndo un cambio en los datos es de escala (magnitud) y cu\u00e1ndo es de comportamiento (direcci\u00f3n).</p> <ol> <li> <p>Agronom\u00eda: Diagn\u00f3stico Nutricional (Colinealidad) Se analizan dos muestras de suelo de lotes vecinos. Los vectores de nutrientes (Nitr\u00f3geno, F\u00f3sforo) en ppm son:</p> \\[\\mathbf{x}_A = \\begin{pmatrix} 20 \\\\ 10 \\end{pmatrix}, \\quad \\mathbf{x}_B = \\begin{pmatrix} 60 \\\\ 30 \\end{pmatrix}\\] <ol> <li> <p>Calcule la magnitud (riqueza total nutricional) de cada lote: \\(\\lVert \\mathbf{x}_A \\rVert\\) y \\(\\lVert \\mathbf{x}_B \\rVert\\).</p> </li> <li> <p>Calcule la direcci\u00f3n (\u00e1ngulo \\(\\theta\\)) de cada vector respecto al eje de Nitr\u00f3geno.</p> </li> <li> <p>Interpretaci\u00f3n: \u00bfPuede afirmar que el Lote B tiene un \\\"balance qu\u00edmico\\\" diferente al Lote A, o simplemente est\u00e1 \\\"m\u00e1s concentrado\\\"? Justifique usando el \u00e1ngulo.</p> </li> </ol> </li> <li> <p>Finanzas: Perfiles de Riesgo Dos fondos de inversi\u00f3n distribuyen su capital en (Bonos del Estado, Acciones Tecnol\u00f3gicas). Los vectores en millones de USD son:</p> \\[\\mathbf{f}_1 = \\begin{pmatrix} 8 \\\\ 2 \\end{pmatrix}, \\quad \\mathbf{f}_2 = \\begin{pmatrix} 3 \\\\ 6 \\end{pmatrix}\\] <ol> <li> <p>\u00bfQu\u00e9 fondo maneja mayor capital total? (Compare normas).</p> </li> <li> <p>Calcule el \u00e1ngulo de cada fondo respecto al eje de \\\"Bonos del Estado\\\" (\\(x_1\\)).</p> </li> <li> <p>Si definimos un perfil \\\"Conservador\\\" como aquel con \\(\\theta &lt; 30^\\circ\\) y \\\"Agresivo\\\" como \\(\\theta &gt; 60^\\circ\\), clasifique a cada fondo.</p> </li> </ol> </li> <li> <p>Ingenier\u00eda/Mecatr\u00f3nica: Fuerza Resultante en 3D Un dron agr\u00edcola est\u00e1 sometido a tres fuerzas de viento representadas por el vector \\(\\mathbf{v} = (3, 4, 12)\\) m/s (componentes en \\(x, y, z\\)).</p> <ol> <li> <p>Calcule la velocidad total del viento (la rapidez) hallando \\(\\lVert \\mathbf{v} \\rVert\\). (Pista: \\(3^2+4^2=25\\) y \\(12^2=144\\)).</p> </li> <li> <p>Calcule los cosenos directores. \u00bfCu\u00e1l es la componente dominante?</p> </li> <li> <p>Si el dron solo puede tolerar vientos verticales (\\(z\\)) que representen menos del 50% de la fuerza total del viento (es decir, \\(\\cos(\\gamma) &lt; 0.5\\)), \u00bfes seguro volar?</p> </li> </ol> </li> <li> <p>Desaf\u00edo de Python: Normalizaci\u00f3n de Datos En Inteligencia Artificial, a menudo necesitamos que los vectores tengan una longitud est\u00e1ndar de 1 (vectores unitarios) para compararlos justamente. Escriba un peque\u00f1o script o pseudoc\u00f3digo que:</p> <ul> <li> <p>Defina el vector \\(\\mathbf{v} = [10, 20, 20]\\).</p> </li> <li> <p>Calcule su norma \\(L = \\lVert \\mathbf{v} \\rVert\\).</p> </li> <li> <p>Cree un nuevo vector \\(\\mathbf{u} = \\mathbf{v} / L\\).</p> </li> <li> <p>Verifique computacionalmente que la norma del nuevo vector \\(\\mathbf{u}\\) es igual a 1.</p> </li> </ul> </li> </ol> <p>[^1]: \\(\\mathbf{x} = (120, 50, 3, 6{,}2)^\\top\\) Significa que el vector es columna, y lo hemos escrito como fila</p>"},{"location":"matrices-especiales.html","title":"Matrices Especiales y sus Propiedades","text":"<p>En el mundo del \u00c1lgebra Lineal Computacional, no todas las matrices son iguales. Existen ciertas estructuras \"privilegiadas\" que hacen que los algoritmos de Inteligencia Artificial funcionen miles de veces m\u00e1s r\u00e1pido o garanticen que un entrenamiento converja a una soluci\u00f3n estable. En este cap\u00edtulo, exploraremos estas joyas matem\u00e1ticas.</p>"},{"location":"matrices-especiales.html#matrices-simetricas-el-espejo-de-los-datos","title":"Matrices Sim\u00e9tricas: El Espejo de los Datos","text":"<p>Antes de entrar en definiciones rigurosas, pensemos en una red de sensores en un cultivo. La distancia entre el Sensor A y el Sensor B es la misma que entre el B y el A. Esta reciprocidad es la esencia de la simetr\u00eda.</p>"},{"location":"matrices-especiales.html#definicion-formal","title":"Definici\u00f3n Formal","text":"<p>Una matriz cuadrada \\(\\mathbf{A} \\in \\mathbb{R}^{n \\times n}\\) se dice sim\u00e9trica si es igual a su transpuesta: \\(\\(\\mathbf{A} = \\mathbf{A}^\\top\\)\\) Esto implica que sus elementos reflejan esa igualdad respecto a la diagonal principal: \\(a_{ij} = a_{ji}\\) para todo \\(i, j\\).</p> Aplicaci\u00f3n: Redes de Sensores y Adyacencia Imagine que monitoreamos una plantaci\u00f3n con 3 torres de control comunicadas entre s\u00ed. Queremos representar la distancia (o la calidad de la se\u00f1al) entre ellas. $$\\mathbf{D} = \\begin{bmatrix}  0 &amp; 50 &amp; 120 \\\\  50 &amp; 0 &amp; 80 \\\\  120 &amp; 80 &amp; 0  \\end{bmatrix}$$ Note que $d_{12} = 50$ (Torre 1 a Torre 2) es igual a $d_{21} = 50$. Esta matriz es sim\u00e9trica. En IA, las matrices de correlaci\u00f3n y covarianza (que veremos m\u00e1s adelante) son siempre sim\u00e9tricas."},{"location":"matrices-especiales.html#propiedad-espectral-teorema-espectral","title":"Propiedad Espectral (Teorema Espectral)","text":"<p>La raz\u00f3n por la que las matrices sim\u00e9tricas son tan importantes en IA, no es solo est\u00e9tica. Tienen una propiedad computacional vital: Sus autovalores[^1] son siempre n\u00fameros reales (no complejos) y sus autovectores son ortogonales entre s\u00ed. Esto garantiza estabilidad num\u00e9rica.</p>"},{"location":"matrices-especiales.html#matrices-definidas-positivas-la-energia-del-sistema","title":"Matrices Definidas Positivas: La Energ\u00eda del Sistema","text":"<p>Este es quiz\u00e1s el concepto m\u00e1s importante para entender la optimizaci\u00f3n (c\u00f3mo aprenden las redes neuronales).</p> <p>Imagine una funci\u00f3n de costo (error) que tiene forma de \"cuenco\" o \"taz\u00f3n\". Si soltamos una canica (el algoritmo), esta caer\u00e1 inevitablemente al fondo (el m\u00ednimo error). Una matriz Definida Positiva garantiza que esa superficie tenga esa forma de cuenco perfecto, sin puntos de silla ni ca\u00eddas al infinito.</p>"},{"location":"matrices-especiales.html#definicion-formal_1","title":"Definici\u00f3n Formal","text":"<p>Una matriz sim\u00e9trica \\(\\mathbf{A}\\) es Definida Positiva (DP) si para cualquier vector no nulo \\(\\mathbf{x} \\in \\mathbb{R}^n\\): \\(\\(\\mathbf{x}^\\top \\mathbf{A} \\mathbf{x} &gt; 0\\)\\) El t\u00e9rmino \\(\\mathbf{x}^\\top \\mathbf{A} \\mathbf{x}\\) se conoce como Forma Cuadr\u00e1tica. Si el resultado es \\(\\geq 0\\), se llama Semidefinida Positiva (SDP).</p> Aplicaci\u00f3n: Funci\u00f3n de Costo en Riego Automatizado Queremos minimizar el gasto de energ\u00eda ($J$) de una bomba de agua. Este costo depende de dos variables de control: la velocidad del motor ($v$) y la presi\u00f3n de salida ($p$). $$\\mathbf{x} = \\begin{bmatrix} v \\\\ p \\end{bmatrix}$$  El modelo de costo energ\u00e9tico se define como una forma cuadr\u00e1tica: $$J(\\mathbf{x}) = \\mathbf{x}^\\top \\mathbf{Q} \\mathbf{x}$$  Supongamos un punto de operaci\u00f3n $\\mathbf{x} = [2, 4]^\\top$ (2000 RPM y 4 Bar) y una matriz de coeficientes del sistema $\\mathbf{Q}$: $$\\mathbf{Q} = \\begin{bmatrix} 2 &amp; 1 \\\\ 1 &amp; 3 \\end{bmatrix}$$ *(Nota: $\\mathbf{Q}$ es sim\u00e9trica y sus autovalores son positivos, por lo tanto es Definida Positiva).*  **C\u00e1lculo paso a paso:**  1\\. Primero multiplicamos la matriz $\\mathbf{Q}$ por el vector $\\mathbf{x}$: $$\\mathbf{Q}\\mathbf{x} = \\begin{bmatrix} 2 &amp; 1 \\\\ 1 &amp; 3 \\end{bmatrix} \\begin{bmatrix} 2 \\\\ 4 \\end{bmatrix} = \\begin{bmatrix} (2)(2) + (1)(4) \\\\ (1)(2) + (3)(4) \\end{bmatrix} = \\begin{bmatrix} 8 \\\\ 14 \\end{bmatrix}$$  2\\. Luego multiplicamos el vector fila $\\mathbf{x}^\\top$ por el resultado anterior: $$J = \\begin{bmatrix} 2 &amp; 4 \\end{bmatrix} \\cdot \\begin{bmatrix} 8 \\\\ 14 \\end{bmatrix}$$  3\\. Realizamos el producto punto final: $$J = (2)(8) + (4)(14) = 16 + 56 = \\mathbf{72} \\text{ unidades de energ\u00eda}$$  **Conclusi\u00f3n:** Dado que el resultado ($72$) es positivo, confirmamos la propiedad de la matriz. Al ser $\\mathbf{Q}$ definida positiva, la superficie de costo tiene forma de \\\"taz\u00f3n\\\", garantizando que el algoritmo de optimizaci\u00f3n (como el Descenso de Gradiente) siempre podr\u00e1 descender hacia un m\u00ednimo estable sin oscilaciones infinitas."},{"location":"matrices-especiales.html#verificacion-computacional","title":"Verificaci\u00f3n Computacional","text":"<p>\u00bfC\u00f3mo sabemos si una matriz es DP en Python? Verificamos que todos sus autovalores sean positivos.</p> <pre><code>import numpy as np\n\n# Matriz Simetrica\nA = np.array([[2, -1, 0], \n              [-1, 2, -1], \n              [0, -1, 2]])\n\n# Verificamos Simetria\nes_simetrica = np.allclose(A, A.T)\nprint(f\"Es simetrica: {es_simetrica}\")\n\n# Verificamos si es Definida Positiva (Autovalores &gt; 0)\nautovalores = np.linalg.eigvals(A)\nes_def_positiva = np.all(autovalores &gt; 0)\n\nprint(f\"Autovalores: {autovalores}\")\nprint(f\"Es Definida Positiva: {es_def_positiva}\")\n</code></pre>"},{"location":"matrices-especiales.html#matrices-diagonales-e-identidad","title":"Matrices Diagonales e Identidad","text":"<p>Son las matrices m\u00e1s \\\"limpias\\\". Toda la informaci\u00f3n est\u00e1 en la diagonal principal; fuera de ella, todo es ruido (ceros).</p>"},{"location":"matrices-especiales.html#definicion-y-ventajas","title":"Definici\u00f3n y Ventajas","text":"<p>Una matriz diagonal \\(\\mathbf{D}\\) tiene \\(d_{ij} = 0\\) si \\(i \\neq j\\). \\(\\(\\mathbf{D} = \\text{diag}(\\lambda_1, \\lambda_2, \\dots, \\lambda_n)\\)\\) Ventaja Computacional:</p> <ul> <li> <p>Multiplicar por \\(\\mathbf{D}\\) es solo escalar cada elemento (barato computacionalmente).</p> </li> <li> <p>La inversa \\(\\mathbf{D}^{-1}\\) es trivial: solo invertimos los elementos de la diagonal (\\(1/\\lambda_i\\)).</p> </li> </ul> Aplicaci\u00f3n: Sistemas de Cultivos Independientes Si gestionamos 3 invernaderos aislados donde el clima de uno NO afecta al otro, la matriz del sistema es diagonal. $$\\begin{bmatrix} T_1 \\\\ T_2 \\\\ T_3 \\end{bmatrix}_{nuevo} = \\begin{bmatrix} 0.9 &amp; 0 &amp; 0 \\\\ 0 &amp; 0.8 &amp; 0 \\\\ 0 &amp; 0 &amp; 0.95 \\end{bmatrix} \\begin{bmatrix} T_1 \\\\ T_2 \\\\ T_3 \\end{bmatrix}_{actual}$$ Aqu\u00ed, el invernadero 1 retiene el 90% del calor, el 2 el 80%, etc. No hay \\\"mezcla\\\" de t\u00e9rminos."},{"location":"matrices-especiales.html#matrices-ortogonales-rotaciones-perfectas","title":"Matrices Ortogonales: Rotaciones Perfectas","text":"<p>Las matrices ortogonales son fundamentales en rob\u00f3tica (mecatr\u00f3nica) y en el preprocesamiento de im\u00e1genes (PCA). Representan transformaciones r\u00edgidas: rotan los datos pero no los estiran ni los deforman.</p>"},{"location":"matrices-especiales.html#definicion-formal_2","title":"Definici\u00f3n Formal","text":"<p>Una matriz cuadrada \\(\\mathbf{Q}\\) es ortogonal si su transpuesta es igual a su inversa: \\(\\(\\mathbf{Q}^\\top = \\mathbf{Q}^{-1} \\implies \\mathbf{Q}^\\top \\mathbf{Q} = \\mathbf{Q} \\mathbf{Q}^\\top = \\mathbf{I}\\)\\) Esto implica que las columnas de \\(\\mathbf{Q}\\) son vectores unitarios y perpendiculares entre s\u00ed.</p> Aplicaci\u00f3n: Mecatr\u00f3nica: Rotaci\u00f3n de un Brazo Rob\u00f3tico Un brazo rob\u00f3tico recolector de frutas necesita rotar su pinza sin cambiar el tama\u00f1o de la fruta que ve. La matriz de rotaci\u00f3n en 2D es el ejemplo cl\u00e1sico de matriz ortogonal: $$\\mathbf{R}(\\theta) = \\begin{bmatrix} \\cos \\theta &amp; -\\sin \\theta \\\\ \\sin \\theta &amp; \\cos \\theta \\end{bmatrix}$$ Si aplicamos esta matriz a un vector posici\u00f3n $\\mathbf{v}$, la nueva posici\u00f3n $\\mathbf{v}' = \\mathbf{R}\\mathbf{v}$ tendr\u00e1 exactamente la misma longitud (norma) que $\\mathbf{v}$. $||\\mathbf{R}\\mathbf{v}|| = ||\\mathbf{v}||$."},{"location":"matrices-especiales.html#implementacion-en-python","title":"Implementaci\u00f3n en Python","text":"<p>Podemos verificar la ortogonalidad comprobando si \\(Q @ Q.T\\) es la identidad.</p> <pre><code>theta = np.radians(45) # Rotacion de 45 grados\nc, s = np.cos(theta), np.sin(theta)\n\nQ = np.array([[c, -s], \n              [s, c]])\n\n# Verificacion: Q @ Q.T debe ser Identidad\nidentidad_aprox = Q @ Q.T\nprint(\"Q @ Q.T (deberia ser Identidad):\")\nprint(identidad_aprox)\n</code></pre>"},{"location":"matrices-especiales.html#conexion-integradora-la-matriz-de-covarianza","title":"Conexi\u00f3n Integradora: La Matriz de Covarianza","text":"<p>Cerramos este cap\u00edtulo conectando todo. Cuando recolectamos datos del mundo real (Big Data Agroambiental), construimos la **Matriz de Covarianza** (\\(\\mathbf{\\Sigma}\\)).</p> <p>Esta matriz es m\u00e1gica porque cumple todo lo que vimos: 1. Es **Sim\u00e9trica** (la covarianza de humedad vs temperatura es igual a temperatura vs humedad). 2. Es **Semidefinida Positiva** (la varianza siempre es no negativa). 3. Sus autovectores son **Ortogonales** (apuntan a las direcciones principales de variaci\u00f3n de los datos).</p> <p>Esta matriz ser\u00e1 la protagonista en el siguiente cap\u00edtulo sobre Autovalores y An\u00e1lisis de Componentes Principales (PCA).</p>"},{"location":"matrices-especiales.html#propiedades-y-conexiones","title":"Propiedades y conexiones","text":"<ul> <li> <p>Toda matriz de covarianza \\(\\mathbf{\\Sigma}\\) es sim\u00e9trica y SDP.</p> </li> <li> <p>Si \\(\\mathbf{A}\\) es SDP, todos sus autovalores son no negativos (\\(\\lambda_i \\geq 0\\)).</p> </li> <li> <p>Si \\(\\mathbf{A}\\) es DP, entonces \\(\\det(\\mathbf{A}) &gt; 0\\) y es invertible.</p> </li> </ul>"},{"location":"matrices-especiales.html#interpretacion-en-ciencia-de-datos","title":"Interpretaci\u00f3n en ciencia de datos","text":"<p>La condici\u00f3n SDP garantiza que la varianza calculada en cualquier direcci\u00f3n proyectada sea no negativa, lo cual es una consistencia estad\u00edstica fundamental. En PCA, los autovalores de \\(\\mathbf{\\Sigma}\\) representan varianzas explicadas; si fueran negativos, el modelo f\u00edsico estar\u00eda roto.</p> <p>Ejemplo. La matriz \\(\\mathbf{A} = \\begin{pmatrix} 2 &amp; 1 \\\\ 1 &amp; 2 \\end{pmatrix}\\) es sim\u00e9trica y DP, ya que su determinante es \\(3 &gt; 0\\) y su traza es \\(4 &gt; 0\\) (criterio r\u00e1pido para matrices \\(2 \\times 2\\)).</p>"},{"location":"matrices-especiales.html#matrices-definidas-positivas","title":"Matrices Definidas Positivas","text":"<p>El concepto de una matriz definida positiva es an\u00e1logo a la idea de un n\u00famero real positivo (\\(a &gt; 0\\)), pero extendido al \u00e1lgebra matricial. En ingenier\u00eda, estas matrices son fundamentales porque garantizan la estabilidad de los sistemas y la existencia de m\u00ednimos \u00fanicos en problemas de optimizaci\u00f3n (costos, energ\u00eda, error).</p>"},{"location":"matrices-especiales.html#definicion-paso-a-paso","title":"Definici\u00f3n paso a paso","text":"<p>Sea \\(\\mathbf{A} \\in \\mathbb{R}^{n \\times n}\\) una matriz sim\u00e9trica. Decimos que \\(\\mathbf{A}\\) es definida positiva si satisface la siguiente condici\u00f3n energ\u00e9tica: \\(\\(\\mathbf{x}^\\top \\mathbf{A} \\mathbf{x} &gt; 0, \\quad \\text{para todo vector } \\mathbf{x} \\in \\mathbb{R}^n, \\mathbf{x} \\neq \\mathbf{0}.\\)\\) El t\u00e9rmino escalar \\(E = \\mathbf{x}^\\top \\mathbf{A} \\mathbf{x}\\) se conoce como forma cuadr\u00e1tica. Geom\u00e9tricamente, si \\(\\mathbf{A}\\) es definida positiva, la gr\u00e1fica de esta funci\u00f3n cuadr\u00e1tica tiene forma de \"taz\u00f3n\" o \"cuenco\" curvado hacia arriba, lo que implica que tiene un fondo (un m\u00ednimo global).</p>"},{"location":"matrices-especiales.html#criterios-de-identificacion","title":"Criterios de identificaci\u00f3n","text":"<p>Para verificar si una matriz es definida positiva sin probar infinitos vectores, utilizamos dos criterios pr\u00e1cticos:</p> <ol> <li> <p>Autovalores (Eigenvalues): Todos los autovalores \\(\\lambda_i\\) de \\(\\mathbf{A}\\) deben ser estrictamente positivos (\\(\\lambda_i &gt; 0\\)).</p> </li> <li> <p>Criterio de Sylvester: Todos los determinantes de los sub-bloques principales superiores (los menores principales) deben ser positivos.</p> </li> </ol>"},{"location":"matrices-especiales.html#aplicacion-en-ingenieria-agricola-minimizacion-de-costos","title":"Aplicaci\u00f3n en Ingenier\u00eda Agr\u00edcola: Minimizaci\u00f3n de Costos","text":"<p>En la optimizaci\u00f3n de procesos agroindustriales, buscamos minimizar funciones de costo. La condici\u00f3n matem\u00e1tica para asegurar que hemos encontrado un costo m\u00ednimo (y no un m\u00e1ximo o un punto de silla) es que la matriz de segundas derivadas (la Matriz Hessiana) sea definida positiva.</p> <p>Ejemplo pr\u00e1ctico: Un ingeniero agr\u00edcola desea minimizar el costo operativo \\(C\\) de un sistema de fertirriego, el cual depende de dos variables:</p> <ul> <li> <p>\\(w\\): Cantidad de agua (\\(m^3/ha\\)).</p> </li> <li> <p>\\(f\\): Cantidad de fertilizante (\\(kg/ha\\)).</p> </li> </ul> <p>Supongamos que el modelo de costos se aproxima localmente mediante una funci\u00f3n cuadr\u00e1tica: \\(\\(C(w, f) = 2w^2 + 2wf + 4f^2 - 100w - 200f + 5000.\\)\\) Para verificar si este sistema tiene un costo m\u00ednimo estable, analizamos la curvatura de la funci\u00f3n mediante su matriz Hessiana \\(\\mathbf{H}\\) (la matriz de coeficientes cuadr\u00e1ticos): \\(\\(\\mathbf{H} = \\begin{pmatrix} \\frac{\\partial^2 C}{\\partial w^2} &amp; \\frac{\\partial^2 C}{\\partial w \\partial f} \\\\ \\frac{\\partial^2 C}{\\partial f \\partial w} &amp; \\frac{\\partial^2 C}{\\partial f^2} \\end{pmatrix} = \\begin{pmatrix} 4 &amp; 2 \\\\ 2 &amp; 8 \\end{pmatrix}.\\)\\)</p> <p>Verificaci\u00f3n paso a paso:</p> <ol> <li> <p>Simetr\u00eda: La matriz es sim\u00e9trica (\\(H_{12} = H_{21} = 2\\)).</p> </li> <li> <p>Criterio de Autovalores: Calculamos \\(\\det(\\mathbf{H} - \\lambda \\mathbf{I}) = (4-\\lambda)(8-\\lambda) - 4 = \\lambda^2 - 12\\lambda + 28 = 0\\). Resolviendo, obtenemos \\(\\lambda_1 \\approx 9.4\\) y \\(\\lambda_2 \\approx 2.6\\).</p> </li> <li> <p>Conclusi\u00f3n: Como \\(\\lambda_1 &gt; 0\\) y \\(\\lambda_2 &gt; 0\\), la matriz \\(\\mathbf{H}\\) es definida positiva.</p> </li> </ol> <p>Interpretaci\u00f3n Ingenieril: Dado que la matriz es definida positiva, la superficie de costos es convexa (tiene forma de taz\u00f3n). Esto garantiza al ingeniero que existe una \u00fanica combinaci\u00f3n \u00f3ptima de agua y fertilizante que minimiza los costos operativos, permitiendo el uso de algoritmos de optimizaci\u00f3n (como el Descenso de Gradiente) con total seguridad de convergencia.</p>"},{"location":"matrices-especiales.html#conexion-integradora-la-matriz-de-covarianza_1","title":"Conexi\u00f3n integradora: la matriz de covarianza","text":"<p>En ciencia de datos agro-ambiental, la matriz m\u00e1s omnipresente es la matriz de covarianza muestral: \\(\\(\\mathbf{\\Sigma} = \\frac{1}{m-1} \\mathbf{X}_c^\\top \\mathbf{X}_c,\\)\\) donde \\(\\mathbf{X}_c\\) es la matriz de datos centrada (media cero). Esta estructura unifica todos los conceptos anteriores:</p> <ul> <li> <p>Es cuadrada y sim\u00e9trica (propiedad de \\(\\mathbf{A}^\\top \\mathbf{A}\\)).</p> </li> <li> <p>Es semidefinida positiva (reflejando la naturaleza no negativa de la dispersi\u00f3n de datos).</p> </li> <li> <p>Invertibilidad y Colinealidad: Si dos variables son colineales (ej. \"kg de fertilizante\" y \"g de nitr\u00f3geno aportado\"), las columnas de \\(\\mathbf{X}\\) son dependientes, el determinante de \\(\\mathbf{\\Sigma}\\) cae a 0, y la matriz no se puede invertir. Esto alerta al cient\u00edfico de datos sobre redundancia en el modelo.</p> </li> </ul> <p>As\u00ed, el producto, la transpuesta, el determinante y la inversa no son conceptos aislados, sino herramientas coordinadas que permiten modelar, transformar y diagnosticar la calidad de los datos agro-ambientales.</p> <p>[^1]: Los autovalores son valores \\(\\lambda\\) que satisfacen \\(|A-\\lambda I| = 0\\)</p>"},{"location":"operaciones-estructuras.html","title":"Poniendo el Motor en Marcha: Aritm\u00e9tica Tensorial","text":""},{"location":"operaciones-estructuras.html#suma-de-vectores-y-aplicaciones","title":"Suma de vectores y Aplicaciones","text":"<p>La suma combina dos vectores componente a componente. En t\u00e9rminos de datos, esta operaci\u00f3n representa la acumulaci\u00f3n o superposici\u00f3n de efectos provenientes de distintas fuentes.</p> <p>Definici\u00f3n formal. Sean \\(\\mathbf{x}, \\mathbf{y} \\in \\mathbb{R}^n\\). La suma \\(\\mathbf{x} + \\mathbf{y}\\) se define como:</p> \\[\\mathbf{x} + \\mathbf{y} =  \\begin{pmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\end{pmatrix} +  \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n \\end{pmatrix} =  \\begin{pmatrix} x_1 + y_1 \\\\ x_2 + y_2 \\\\ \\vdots \\\\ x_n + y_n \\end{pmatrix}.\\] Representaci\u00f3n geom\u00e9trica de la suma vectorial (Ley del Paralelogramo). El vector resultante conecta el origen con la esquina opuesta formada por la proyecci\u00f3n de los vectores $\\mathbf{x}$ y $\\mathbf{y}$. <p>Geom\u00e9tricamente, esto sigue la ley del paralelogramo 1.1: si colocamos el inicio de \\(\\mathbf{y}\\) en la punta final de \\(\\mathbf{x}\\), el vector resultante va desde el origen de \\(\\mathbf{x}\\) hasta la punta final de \\(\\mathbf{y}\\).</p> <p>Ejemplo Ambiental: Inventario de Emisiones Supongamos que en una zona industrial existen dos fuentes principales de contaminaci\u00f3n: una Termoel\u00e9ctrica (\\(\\mathbf{e}_T\\)) y una F\u00e1brica de Cemento (\\(\\mathbf{e}_C\\)). Los vectores representan la emisi\u00f3n diaria (en toneladas) de tres contaminantes distintos: \\([\\text{CO}_2, \\text{NO}_x, \\text{Material Particulado}]\\).</p> \\[\\mathbf{e}_T = \\begin{pmatrix} 100 \\\\ 5 \\\\ 0.5 \\end{pmatrix}, \\quad \\mathbf{e}_C = \\begin{pmatrix} 40 \\\\ 2 \\\\ 3.5 \\end{pmatrix}\\] <p>Para conocer la carga total que recibe la atm\u00f3sfera en esa zona, realizamos la suma vectorial:</p> \\[\\mathbf{e}_{total} = \\mathbf{e}_T + \\mathbf{e}_C =  \\begin{pmatrix} 100 + 40 \\\\ 5 + 2 \\\\ 0.5 + 3.5 \\end{pmatrix} =  \\begin{pmatrix} 140 \\\\ 7 \\\\ 4.0 \\end{pmatrix}\\] <p>Interpretaci\u00f3n: La suma vectorial garantiza la integridad de las variables: sumamos di\u00f3xido de carbono solo con di\u00f3xido de carbono (\\(140\\) ton), y part\u00edculas solo con part\u00edculas (\\(4.0\\) ton). Mezclar componentes (sumar el CO\\(_2\\) de una f\u00e1brica con el polvo de otra) carecer\u00eda de sentido f\u00edsico.</p>"},{"location":"operaciones-estructuras.html#aplicaciones-sectoriales-agro-y-mecatronica","title":"Aplicaciones sectoriales: Agro y Mecatr\u00f3nica","text":"<ul> <li> <p>Fusi\u00f3n de sensores (Agro): Un nodo IoT registra variables clim\u00e1ticas de dos sensores para redundancia. Si el sensor A entrega el vector de estado \\(\\mathbf{s}_A\\) y el sensor B entrega \\(\\mathbf{s}_B\\), la suma (o promedio vectorial) permite reducir el ruido aleatorio y obtener una lectura m\u00e1s robusta del ambiente.</p> </li> <li> <p>Acumulaci\u00f3n temporal (Ambiental): El vector de emisiones diarias de un biodigestor se suma a lo largo de una semana (\\(t=1 \\dots 7\\)) para obtener el impacto total acumulado:</p> \\[\\mathbf{e}_{\\text{semanal}} = \\mathbf{e}_{\\text{lun}} + \\mathbf{e}_{\\text{mar}} + \\dots + \\mathbf{e}_{\\text{dom}}\\] <p>Esto permite reportar totales de \\(\\mathrm{CH}_4\\) y \\(\\mathrm{CO}_2\\) sin perder la distinci\u00f3n entre gases.</p> </li> <li> <p>Composici\u00f3n de insumos (Agroindustrial): En la formulaci\u00f3n de alimento balanceado, el vector nutricional final (prote\u00edna, energ\u00eda, fibra) se construye sumando los aportes vectoriales de cada ingrediente (ma\u00edz, soya, n\u00facleo vitam\u00ednico), lo que permite verificar si la mezcla final cumple con los requerimientos dietarios.</p> </li> <li> <p>Correcci\u00f3n de Trayectoria (Mecatr\u00f3nica/Rob\u00f3tica): Un dron de fumigaci\u00f3n agr\u00edcola debe volar en una ruta ideal representada por el vector de velocidad \\(\\mathbf{v}_{ideal}\\). Sin embargo, enfrenta un viento lateral representado por el vector \\(\\mathbf{v}_{viento}\\). Para mantener el curso, el sistema de control o la IA debe calcular la velocidad real resultante mediante la suma vectorial:</p> \\[\\mathbf{v}_{real} = \\mathbf{v}_{ideal} + \\mathbf{v}_{viento}\\] <p>Si el resultado desv\u00eda al dron del cultivo, la IA debe generar un vector de compensaci\u00f3n opuesto para anular la perturbaci\u00f3n.</p> </li> </ul> <p>En todos estos casos, la suma vectorial permite construir representaciones compuestas que capturan la complejidad de los sistemas f\u00edsicos, prepar\u00e1ndolas para su an\u00e1lisis mediante algoritmos de control o modelos de inteligencia artificial.</p>"},{"location":"operaciones-estructuras.html#multiplicacion-por-un-escalar","title":"Multiplicaci\u00f3n por un escalar","text":"<p>Esta operaci\u00f3n modifica la magnitud del vector sin alterar su l\u00ednea de acci\u00f3n. Matem\u00e1ticamente, escala todas las componentes por un mismo factor \\(\\alpha\\).</p> <p>Definici\u00f3n formal. Dado un escalar \\(\\alpha \\in \\mathbb{R}\\) y un vector \\(\\mathbf{x} \\in \\mathbb{R}^n\\), el producto \\(\\alpha \\mathbf{x}\\) se define como:</p> \\[\\alpha \\mathbf{x} =  \\alpha \\begin{pmatrix} x_1 \\\\ \\vdots \\\\ x_n \\end{pmatrix} =  \\begin{pmatrix} \\alpha x_1 \\\\ \\vdots \\\\ \\alpha x_n \\end{pmatrix}.\\] <p>Interpretaci\u00f3n Geom\u00e9trica: El efecto del escalar \\(\\alpha\\) sobre el vector original \\(\\mathbf{x}\\) depende de su valor:</p> <ul> <li> <p>Si \\(|\\alpha| &gt; 1\\), el vector se alarga (dilataci\u00f3n).</p> </li> <li> <p>Si \\(|\\alpha| &lt; 1\\), el vector se contrae (compresi\u00f3n).</p> </li> <li> <p>Si \\(\\alpha &lt; 0\\), el vector invierte su sentido (\\(180^\\circ\\)), aunque mantiene la misma l\u00ednea de direcci\u00f3n.</p> </li> </ul> Efecto geom\u00e9trico de la multiplicaci\u00f3n escalar. N\u00f3tese c\u00f3mo \u03b1=2 duplica la longitud, mientras que \u03b1=-0.5 reduce la longitud a la mitad e invierte el sentido."},{"location":"operaciones-estructuras.html#aplicaciones-escalamiento-y-control","title":"Aplicaciones: Escalamiento y Control","text":"<ol> <li> <p>Agro (Proyecci\u00f3n de Insumos): Suponga que el vector \\(\\mathbf{d}\\) representa la dosis de fertilizantes para 1 hect\u00e1rea: \\(\\mathbf{d} = [100, 50, 30]^\\top\\) (kg de N, P, K). Si un agricultor desea fertilizar un lote de 15 hect\u00e1reas, el requerimiento total es simplemente el vector escalado por la superficie:</p> \\[\\mathbf{Total} = 15 \\cdot \\mathbf{d} = \\begin{pmatrix} 1500 \\\\ 750 \\\\ 450 \\end{pmatrix} \\text{ kg}.\\] </li> <li> <p>Mecatr\u00f3nica (Ganancia de Control): En un sistema de control de un robot, el \"error\" de posici\u00f3n es un vector \\(\\mathbf{e}\\) (diferencia entre d\u00f3nde est\u00e1 y d\u00f3nde deber\u00eda estar). El controlador aplica una correcci\u00f3n proporcional multiplicando ese error por una ganancia \\(K_p\\) (un escalar).</p> \\[\\mathbf{u} = K_p \\cdot \\mathbf{e}\\] <p>Si \\(K_p\\) es muy grande, el robot reacciona violentamente (gran vector de fuerza); si es peque\u00f1o, reacciona suavemente.</p> </li> </ol>"},{"location":"operaciones-estructuras.html#producto-punto-producto-escalar","title":"Producto punto (producto escalar)","text":"<p>El producto punto es la operaci\u00f3n fundamental para conectar la geometr\u00eda (\u00e1ngulos, longitudes) con el \u00e1lgebra. Mide el grado de alineaci\u00f3n entre dos vectores: si apuntan en la misma direcci\u00f3n, el valor es grande y positivo; si son perpendiculares, es cero; si apuntan en sentidos opuestos, es negativo.</p> <p>Definici\u00f3n formal.</p> \\[\\cdot : \\mathbb{R}^n \\times \\mathbb{R}^n \\to \\mathbb{R}, \\quad (\\mathbf{x}, \\mathbf{y}) \\mapsto \\mathbf{x} \\cdot \\mathbf{y} = \\sum_{i=1}^{n} x_i y_i.\\]"},{"location":"operaciones-estructuras.html#interpretacion-geometrica-y-similitud","title":"Interpretaci\u00f3n Geom\u00e9trica y Similitud","text":"<p>Adem\u00e1s de la operaci\u00f3n algebraica componente a componente, el producto punto satisface una identidad geom\u00e9trica fundamental, ilustrada en la Figura 1.3:</p> \\[\\mathbf{x} \\cdot \\mathbf{y} = \\lVert \\mathbf{x} \\rVert \\lVert \\mathbf{y} \\rVert \\cos(\\theta),\\] <p>donde \\(\\theta\\) es el \u00e1ngulo entre los vectores. Esta relaci\u00f3n permite aislar el t\u00e9rmino del coseno para definir la Similitud Coseno, una m\u00e9trica esencial en Inteligencia Artificial para medir qu\u00e9 tan similares son dos vectores independientemente de su magnitud:</p> Relaci\u00f3n entre magnitudes y \u00e1ngulo. El producto punto conecta la longitud de los vectores con el coseno del \u00e1ngulo \u03b8 que forman entre s\u00ed. \\[\\cos(\\theta) = \\frac{\\mathbf{x} \\cdot \\mathbf{y}}{\\lVert \\mathbf{x} \\rVert \\lVert \\mathbf{y} \\rVert}.\\] <p>Como se observa en la Figura 1.4, geom\u00e9tricamente esto equivale a evaluar la proyecci\u00f3n o \\\"sombra\\\" de un vector sobre el otro. Si el \u00e1ngulo es cero (vectores alineados), la similitud es m\u00e1xima (1); si son ortogonales (90\u00b0), es nula (0).</p> Interpretaci\u00f3n de la proyecci\u00f3n. La l\u00ednea violeta muestra la componente de y que est\u00e1 \"alineada\" con x. El producto punto es el resultado de multiplicar esta proyecci\u00f3n por la longitud total de x."},{"location":"operaciones-estructuras.html#aplicaciones-en-ingenieria-y-agro","title":"Aplicaciones en Ingenier\u00eda y Agro","text":"<ol> <li> <p>Agro (Firmas Espectrales): En teledetecci\u00f3n, una planta sana tiene una \"firma\"\u00a0o vector ideal \\(\\mathbf{v}_{sana}\\) (valores de reflectancia en distintas bandas). Si el dron mide un vector actual \\(\\mathbf{v}_{medido}\\), calculamos el producto punto (normalizado) entre ambos.</p> <ul> <li> <p>Si \\(\\cos(\\theta) \\approx 1\\), la firma es casi id\u00e9ntica \\(\\to\\) Planta Sana.</p> </li> <li> <p>Si \\(\\cos(\\theta) \\ll 1\\), la alineaci\u00f3n es baja \\(\\to\\) Posible estr\u00e9s h\u00eddrico o plaga.</p> </li> </ul> </li> <li> <p>Mecatr\u00f3nica (C\u00e1lculo de Trabajo y Potencia): Para un robot m\u00f3vil, el trabajo mec\u00e1nico \\(W\\) realizado al mover una carga es el producto punto entre el vector de fuerza aplicada \\(\\mathbf{F}\\) y el vector de desplazamiento \\(\\mathbf{d}\\):</p> \\[W = \\mathbf{F} \\cdot \\mathbf{d} = \\lVert \\mathbf{F} \\rVert \\lVert \\mathbf{d} \\rVert \\cos(\\theta)\\] <p>Si el robot aplica fuerza perpendicular al movimiento (\\(\\theta=90^\\circ\\)), el producto punto es 0 y no se realiza trabajo \u00fatil (energ\u00eda desperdiciada).</p> </li> <li> <p>Administrativo (Sistemas de Puntuaci\u00f3n): Sea \\(\\mathbf{w}\\) un vector de \"pesos\"\u00a0o importancia para tres criterios (Costo, Calidad, Tiempo) y \\(\\mathbf{x}\\) el vector de puntajes de un proveedor. El puntaje total es simplemente:</p> \\[\\text{Score} = \\mathbf{w} \\cdot \\mathbf{x} = w_1 x_1 + w_2 x_2 + w_3 x_3\\] <p>Esta es la base de las redes neuronales: una neurona realiza un producto punto entre los datos de entrada y sus pesos sin\u00e1pticos.</p> </li> </ol>"},{"location":"operaciones-estructuras.html#interpretacion-geometrica-del-producto-punto","title":"Interpretaci\u00f3n geom\u00e9trica del Producto Punto","text":"<p>El producto punto (\\(\\mathbf{x} \\cdot \\mathbf{y}\\)) es mucho m\u00e1s que una suma de productos de componentes: es la operaci\u00f3n geom\u00e9trica fundamental que cuantifica cu\u00e1nto dos vectores apuntan en la misma direcci\u00f3n. Esta noci\u00f3n de \"alineaci\u00f3n direccional\" es la base de t\u00e9cnicas esenciales en inteligencia artificial, como la similitud coseno, la proyecci\u00f3n ortogonal y el An\u00e1lisis de Componentes Principales (PCA).</p> <p>La definici\u00f3n geom\u00e9trica del producto punto para dos vectores \\(\\mathbf{x}, \\mathbf{y} \\in \\mathbb{R}^n\\) es:</p> \\[\\mathbf{x} \\cdot \\mathbf{y} = \\lVert \\mathbf{x} \\rVert \\, \\lVert \\mathbf{y} \\rVert \\cos(\\theta),\\] <p>donde \\(\\lVert \\mathbf{x} \\rVert\\) y \\(\\lVert \\mathbf{y} \\rVert\\) son las longitudes euclidianas de los vectores, y \\(\\theta \\in [0, \\pi]\\) es el \u00e1ngulo entre ellos.</p> <p>Esta f\u00f3rmula revela tres casos clave:</p> <ul> <li> <p>Si \\(\\theta = 0^\\circ\\) (vectores paralelos y en la misma direcci\u00f3n), \\(\\cos(\\theta) = 1\\) y el producto punto es m\u00e1ximo.</p> </li> <li> <p>Si \\(\\theta = 90^\\circ\\) (vectores ortogonales), \\(\\cos(\\theta) = 0\\) y el producto punto es cero.</p> </li> <li> <p>Si \\(\\theta = 180^\\circ\\) (vectores opuestos), \\(\\cos(\\theta) = -1\\) y el producto punto es m\u00ednimo (negativo).</p> </li> </ul> <p>Conexi\u00f3n con aplicaciones en IA y agro-ambiente. En el an\u00e1lisis de datos, el producto punto permite:</p> <ul> <li> <p>Comparar perfiles de fertilizaci\u00f3n entre parcelas: si \\(\\theta\\) es peque\u00f1o, las pr\u00e1cticas son similares.</p> </li> <li> <p>Detectar animales at\u00edpicos en un hato: un vector fisiol\u00f3gico con \\(\\theta\\) grande respecto a la media indica una posible anomal\u00eda.</p> </li> <li> <p>Calcular la similitud coseno (normalizando las magnitudes): \\(\\frac{\\mathbf{x} \\cdot \\mathbf{y}}{\\lVert \\mathbf{x} \\rVert \\lVert \\mathbf{y} \\rVert} = \\cos(\\theta)\\), que mide solo la alineaci\u00f3n, ignorando la escala.</p> </li> </ul> <p>Esta interpretaci\u00f3n geom\u00e9trica es el primer paso hacia la comprensi\u00f3n de c\u00f3mo los algoritmos de IA \"ven\" y comparan datos en espacios multidimensionales.</p>"},{"location":"operaciones-estructuras.html#dependencia-de-la-proyeccion","title":"Dependencia de la Proyecci\u00f3n","text":"<p>El concepto m\u00e1s fundamental es la relaci\u00f3n con la proyecci\u00f3n ortogonal, como se ilustra en la figura 1.4. El t\u00e9rmino \\(\\lVert \\mathbf{y} \\rVert \\cos(\\theta)\\) representa precisamente la longitud de la componente del vector \\(\\mathbf{y}\\) que est\u00e1 alineada con \\(\\mathbf{x}\\) (la proyecci\u00f3n, \\(\\mathrm{proj}_{\\mathbf{x}} \\mathbf{y}\\)).</p> <p>Por lo tanto, el producto punto puede reescribirse como:</p> \\[\\mathbf{x} \\cdot \\mathbf{y} = \\lVert \\mathbf{x} \\rVert \\cdot \\left( \\lVert \\mathbf{y} \\rVert \\cos(\\theta) \\right) = \\lVert \\mathbf{x} \\rVert \\cdot \\lVert \\mathrm{proj}_{\\mathbf{x}} \\mathbf{y} \\rVert.\\] <p>El producto punto es, en esencia, la magnitud de \\(\\mathbf{x}\\) multiplicada por la longitud de la \"sombra\" que \\(\\mathbf{y}\\) proyecta sobre \\(\\mathbf{x}\\). El signo de \\(\\mathbf{x} \\cdot \\mathbf{y}\\) depende \u00fanicamente del \\(\\cos(\\theta)\\).</p>"},{"location":"operaciones-estructuras.html#casos-criticos","title":"Casos Cr\u00edticos","text":"<p>El valor del producto punto est\u00e1 dominado por el coseno del \u00e1ngulo \\(\\theta\\), asumiendo que las magnitudes de los vectores son positivas:</p> <ol> <li> <p>Alineaci\u00f3n Perfecta (\\(\\theta = 0^\\circ\\)): Si \\(\\mathbf{x}\\) y \\(\\mathbf{y}\\) apuntan exactamente en la misma direcci\u00f3n, \\(\\cos(0^\\circ) = 1\\).</p> \\[\\mathbf{x} \\cdot \\mathbf{y} = \\lVert \\mathbf{x} \\rVert \\lVert \\mathbf{y} \\rVert.\\] <p>El producto punto es m\u00e1ximo y positivo. En IA, esto indica m\u00e1xima similitud o m\u00e1xima compatibilidad direccional.</p> </li> <li> <p>Ortogonalidad (\\(\\theta = 90^\\circ\\)): Si \\(\\mathbf{x}\\) y \\(\\mathbf{y}\\) son perpendiculares (ortogonales), \\(\\cos(90^\\circ) = 0\\).</p> \\[\\mathbf{x} \\cdot \\mathbf{y} = 0.\\] <p>El producto punto es cero, indicando que los vectores no tienen ninguna componente en com\u00fan y son linealmente independientes, un principio clave en la decorrelaci\u00f3n de datos (ej. PCA).</p> </li> <li> <p>Alineaci\u00f3n Opuesta (\\(\\theta = 180^\\circ\\)): Si \\(\\mathbf{x}\\) y \\(\\mathbf{y}\\) apuntan en direcciones opuestas, \\(\\cos(180^\\circ) = -1\\).</p> \\[\\mathbf{x} \\cdot \\mathbf{y} = -\\lVert \\mathbf{x} \\rVert \\lVert \\mathbf{y} \\rVert.\\] <p>El producto punto es m\u00ednimo y negativo, indicando la m\u00e1xima disimilitud o incompatibilidad.</p> </li> </ol>"},{"location":"operaciones-estructuras.html#sintesis-y-aplicaciones-contextuales-del-producto-punto","title":"S\u00edntesis y Aplicaciones Contextuales del Producto Punto","text":"<p>La utilidad del producto punto (\\(\\mathbf{x} \\cdot \\mathbf{y}\\)) radica en su capacidad para actuar como una medida de alineaci\u00f3n multidimensional o similitud entre vectores. Su valor es grande cuando las magnitudes y la alineaci\u00f3n son altas, reflejando perfiles compatibles. Este concepto es la base de la similitud coseno (\\(\\cos(\\theta) = \\frac{\\mathbf{x} \\cdot \\mathbf{y}}{\\lVert \\mathbf{x} \\rVert \\lVert \\mathbf{y} \\rVert}\\)), ampliamente usada en motores de recomendaci\u00f3n y clustering.</p>"},{"location":"operaciones-estructuras.html#ejemplos-en-contextos-de-modelado-hibrido-agronomico-y-zootecnico","title":"Ejemplos en Contextos de Modelado H\u00edbrido (Agron\u00f3mico y Zoot\u00e9cnico)","text":"<ul> <li> <p>Ejemplo Agron\u00f3mico. Considere dos parcelas de ma\u00edz caracterizadas por el vector de insumos aplicados:</p> \\[\\mathbf{x} = \\begin{pmatrix} 120 \\\\ 50 \\\\ 3 \\end{pmatrix} \\text{ (kg/ha de N, P, K)}, \\quad     \\mathbf{y} = \\begin{pmatrix} 100 \\\\ 60 \\\\ 4 \\end{pmatrix}.\\] <p>El producto punto \\(\\mathbf{x} \\cdot \\mathbf{y} = 12\\,000 + 3\\,000 + 12 = 15\\,012\\) es alto, lo que sugiere un perfil de fertilizaci\u00f3n similar. Esta medida agrupa parcelas con pr\u00e1cticas comparables.</p> </li> <li> <p>Ejemplo Zoot\u00e9cnico. Considere dos vacas lecheras descritas por su historial productivo en una ventana de control:</p> \\[\\mathbf{x} = \\begin{pmatrix} 28 \\\\ 4{,}2 \\\\ 38 \\end{pmatrix}, \\quad     \\mathbf{y} = \\begin{pmatrix} 30 \\\\ 4{,}0 \\\\ 39 \\end{pmatrix},\\] <p>donde las componentes representan d\u00edas en lactancia, producci\u00f3n diaria (L/d\u00eda) y contenido de grasa (%). El producto punto:</p> \\[\\mathbf{x} \\cdot \\mathbf{y} = (28)(30) + (4{,}2)(4{,}0) + (38)(39) = 2338{,}8.\\] <p>Este valor alto refleja perfiles productivos similares: producci\u00f3n alta, lactancia avanzada y elevado contenido de grasa. Esta medida es \u00fatil en sistemas de segmentaci\u00f3n de hatos.</p> </li> </ul> <p>Otros Contextos Aplicados</p> <ul> <li> <p>Ambiental: Dos estaciones de monitoreo registran concentraciones medias (en \\(\\mathrm{\\mu g/m^3}\\)) de \\(\\mathrm{PM_{2.5}}\\), \\(\\mathrm{NO_2}\\) y \\(\\mathrm{O_3}\\): \\(\\mathbf{a}\\) y \\(\\mathbf{b}\\). Un producto punto alto sugiere un patr\u00f3n similar de contaminaci\u00f3n, \u00fatil para agrupar zonas con fuentes emisoras comunes.</p> </li> <li> <p>Administrativo: Dos propuestas presupuestales \\(\\mathbf{p}\\) y \\(\\mathbf{q}\\) (para rubros como infraestructura, capacitaci\u00f3n, operaci\u00f3n) tienen un producto punto que cuantifica la alineaci\u00f3n de prioridades presupuestales.</p> </li> <li> <p>Dise\u00f1o (Industrial/Agr\u00edcola): Dos prototipos de invernadero \\(\\mathbf{d}_1\\) y \\(\\mathbf{d}_2\\) (descritos por \u00e1rea, sensores, consumo energ\u00e9tico). Un producto punto elevado indica dise\u00f1os estructuralmente similares, facilitando la clasificaci\u00f3n de alternativas.</p> </li> </ul> <p>En resumen, el producto punto sirve como un indicador fundamental de cu\u00e1n coherentes o compatibles son dos conjuntos de mediciones o caracter\u00edsticas multidimensionales.</p>"},{"location":"operaciones-estructuras.html#laboratorio-de-programacion-aritmetica-tensorial-en-la-practica","title":"Laboratorio de Programaci\u00f3n: Aritm\u00e9tica Tensorial en la Pr\u00e1ctica","text":"<p>En esta secci\u00f3n, trasladamos las operaciones de suma, escalamiento y producto punto al c\u00f3digo. En IA, estas operaciones no se realizan mediante bucles (for loops), sino a trav\u00e9s de operaciones vectorizadas, las cuales aprovechan el paralelismo del procesador.</p>"},{"location":"operaciones-estructuras.html#implementacion-de-suma-y-escalamiento","title":"Implementaci\u00f3n de Suma y Escalamiento","text":"<p>La suma de vectores requiere que ambos tengan la misma dimensi\u00f3n (shape). La multiplicaci\u00f3n por un escalar, en cambio, utiliza un mecanismo llamado Broadcasting, donde el escalar se \"difunde\" sobre todos los elementos del vector.</p> <pre><code>import numpy as np\nimport torch\n\n# 1. Suma de vectores (Agro: Integraci\u00f3n de dosis de fertilizante)\ndosis_neta = np.array([50, 20, 10])  # N, P, K inicial\nsuplemento = np.array([10,  5,  5])  # Refuerzo aplicado\ndosis_total = dosis_neta + suplemento\nprint(f''Dosis Total (Vector): {dosis_total}'')\n\n# 2. Multiplicaci\u00f3n por Escalar (Mecatr\u00f3nica: Control de Ganancia)\n# Escalar una se\u00f1al de sensor de torque\ntorque_raw = torch.tensor([1.2, 0.8, 1.5])\nganancia = 2.5\ntorque_ajustado = ganancia * torque_raw\nprint(f''Torque ajustado: {torque_ajustado}'')\n</code></pre>"},{"location":"operaciones-estructuras.html#el-producto-punto-cuantificando-la-afinidad","title":"El Producto Punto: Cuantificando la Afinidad","text":"<p>El producto punto es la operaci\u00f3n m\u00e1s importante en IA. En Python, podemos ejecutarlo usando el operador <code>@</code> (recomendado en versiones modernas) o las funciones espec\u00edficas de las librer\u00edas.</p> <pre><code># Vectores de ejemplo (Administraci\u00f3n: Gastos vs Presupuesto)\nunidades = np.array([10, 5, 20])   # Cantidad de productos comprados\nprecios = np.array([1.5, 10.0, 0.5]) # Precio unitario por categor\u00eda\n\n# Producto punto: Suma de (unidades[i] * precios[i])\ngasto_total = np.dot(unidades, precios)\n# Forma alternativa (est\u00e1ndar en \u00e1lgebra lineal de Python):\ngasto_total_alt = unidades @ precios\n\nprint(f''Gasto total calculado via producto punto: ${gasto_total}'')\n</code></pre>"},{"location":"operaciones-estructuras.html#aplicaciones-sectoriales-en-codigo","title":"Aplicaciones Sectoriales en C\u00f3digo","text":"<p>Mecatr\u00f3nica: Resultante de Fuerzas En un brazo rob\u00f3tico, si dos motores ejercen fuerzas representadas por los vectores \\(\\mathbf{f}_1\\) y \\(\\mathbf{f}_2\\), la fuerza resultante sobre el efector final es simplemente \\(f_res = f1 + f2\\). La magnitud de esta fuerza se obtiene con <code>np.linalg.norm(</code>\\(f_res\\)<code>)</code>.</p> <p>Agroindustrial: Mezclas y Diluciones Si un vector \\(\\mathbf{v}\\) representa la concentraci\u00f3n de az\u00facares y acidez de un lote de jugo, y queremos diluirlo al \\(50\\%\\), aplicamos \\(nuevo_lote = 0.5 * v\\). El producto punto se usa para calcular el costo total de la mezcla si tenemos un vector de precios por litro de cada componente.</p>"},{"location":"operaciones-estructuras.html#resumen-de-funciones-clave","title":"Resumen de Funciones Clave","text":"<p>Operaci\u00f3n Sintaxis NumPy Sintaxis PyTorch</p> <p>Suma                 <code>a + b</code> <code>a + b</code>   Escalamiento         <code>k * a</code> <code>k * a</code>   Producto Punto       <code>np.dot(a, b)</code> <code>torch.dot(a, b)</code>   Producto de Matriz   <code>a @ b</code> <code>torch.matmul(a, b)</code></p> <p>: Comparativa de funciones para aritm\u00e9tica tensorial.</p>"},{"location":"operaciones-estructuras.html#multiplicacion-matriz-vector-el-motor-de-las-redes-neuronales","title":"Multiplicaci\u00f3n Matriz-Vector: El Motor de las Redes Neuronales","text":"<p>Antes de entrar en el formalismo, entendamos la intuici\u00f3n: si un vector representa un dato (ej. una parcela, un animal, una propuesta), multiplicar ese vector por una matriz es equivalente a procesar ese dato a trav\u00e9s de un banco de filtros. La matriz toma la informaci\u00f3n cruda, mezcla sus componentes seg\u00fan ciertas reglas (pesos) y produce una nueva representaci\u00f3n m\u00e1s \u00fatil para la toma de decisiones.</p> <p>Esta operaci\u00f3n es el coraz\u00f3n de las redes neuronales profundas (Deep Learning).</p>"},{"location":"operaciones-estructuras.html#definicion-formal","title":"Definici\u00f3n formal","text":"<p>Sea \\(\\mathbf{W} \\in \\mathbb{R}^{m \\times n}\\) una matriz y \\(\\mathbf{x} \\in \\mathbb{R}^n\\) un vector de entrada. Su producto es un nuevo vector \\(\\mathbf{z} \\in \\mathbb{R}^m\\) definido por:</p> \\[\\mathbf{z} = \\mathbf{W} \\mathbf{x} = \\begin{pmatrix} \\mathbf{fila}_1(\\mathbf{W}) \\cdot \\mathbf{x} \\\\ \\vdots \\\\ \\mathbf{fila}_m(\\mathbf{W}) \\cdot \\mathbf{x} \\end{pmatrix}.\\] <p>Cada entrada \\(z_i\\) es el producto punto entre la fila \\(i\\)-\u00e9sima de la matriz y el vector \\(\\mathbf{x}\\). Para que la operaci\u00f3n sea v\u00e1lida, el n\u00famero de columnas de la matriz (\\(n\\)) debe coincidir con la dimensi\u00f3n de entrada del vector.</p>"},{"location":"operaciones-estructuras.html#ejemplo-teorico-transformacion-de-insumos-a-nutrientes","title":"Ejemplo Te\u00f3rico: Transformaci\u00f3n de Insumos a Nutrientes","text":"<p>Imaginemos un sistema inteligente para la formulaci\u00f3n de raciones en ganado lechero. Queremos calcular el aporte nutricional total a partir de una mezcla de ingredientes.</p> <p>1. El Vector de Entrada (\\(\\mathbf{x}\\)): Representa la cantidad de materia prima (en kg) que vamos a utilizar en la mezcla.</p> \\[\\mathbf{x} = \\begin{pmatrix} 10 \\\\ 5 \\end{pmatrix} \\begin{matrix} \\text{(kg de Ma\u00edz)} \\\\ \\text{(kg de Soya)} \\end{matrix}\\] <p>Aqu\u00ed, \\(n=2\\) (tenemos 2 ingredientes).</p> <p>2. La Matriz de Pesos (\\(\\mathbf{W}\\)): Representa el contenido nutricional por cada kg de ingrediente.</p> <ul> <li> <p>La Fila 1 corresponde a la Prote\u00edna Cruda (en kg/kg).</p> </li> <li> <p>La Fila 2 corresponde a la Energ\u00eda Neta (en Mcal/kg).</p> </li> </ul> \\[\\mathbf{W} =  \\begin{pmatrix}  0{,}08 &amp; 0{,}45 \\\\  3{,}20 &amp; 2{,}80  \\end{pmatrix} \\begin{matrix} \\leftarrow \\text{Perfil de Prote\u00edna} \\\\ \\leftarrow \\text{Perfil de Energ\u00eda} \\end{matrix}\\] <p>Aqu\u00ed, \\(m=2\\) (tenemos 2 m\u00e9tricas de salida). Note que las columnas (\\(n=2\\)) coinciden con los ingredientes (Ma\u00edz y Soya).</p> <p>3. El C\u00e1lculo (\\(\\mathbf{z} = \\mathbf{W}\\mathbf{x}\\)): Aplicamos la definici\u00f3n del producto punto fila por columna:</p> \\[\\mathbf{z} =  \\begin{pmatrix} (\\text{Fila}_1 \\cdot \\mathbf{x}) \\\\ (\\text{Fila}_2 \\cdot \\mathbf{x}) \\end{pmatrix} = \\begin{pmatrix} (0{,}08)(10) + (0{,}45)(5) \\\\ (3{,}20)(10) + (2{,}80)(5) \\end{pmatrix}\\] \\[\\mathbf{z} =  \\begin{pmatrix} 0{,}8 + 2{,}25 \\\\ 32{,}0 + 14{,}0 \\end{pmatrix} = \\begin{pmatrix} 3{,}05 \\\\ 46{,}0 \\end{pmatrix} \\begin{matrix} \\text{kg de Prote\u00edna Total} \\\\ \\text{Mcal de Energ\u00eda Total} \\end{matrix}\\] <p>Interpretaci\u00f3n en Inteligencia Artificial: En este ejemplo, la matriz \\(\\mathbf{W}\\) codifica el \"conocimiento\" del sistema sobre los alimentos.</p> <ul> <li> <p>En una Red Neuronal, \\(\\mathbf{x}\\) ser\u00edan los datos de entrada, \\(\\mathbf{W}\\) ser\u00edan los pesos sin\u00e1pticos aprendidos durante el entrenamiento, y \\(\\mathbf{z}\\) ser\u00eda la activaci\u00f3n resultante.</p> </li> <li> <p>La operaci\u00f3n \\(\\mathbf{W}\\mathbf{x}\\) transforma el espacio de \"kilos de comida\" al espacio de \"requerimientos nutricionales\".</p> </li> </ul>"},{"location":"operaciones-estructuras.html#enfoque-en-redes-neuronales-la-capa-densa","title":"Enfoque en Redes Neuronales: La Capa Densa","text":"<p>En el contexto de la inteligencia artificial, esta operaci\u00f3n no es solo \u00e1lgebra; es la definici\u00f3n de una capa densa (fully connected layer). La ecuaci\u00f3n fundamental que ejecuta una neurona artificial (antes de la activaci\u00f3n no lineal) es:</p> \\[\\mathbf{z} = \\mathbf{W} \\mathbf{x} + \\mathbf{b},\\] <p>donde cada elemento cumple un rol biol\u00f3gico-computacional preciso:</p> <ul> <li> <p>\\(\\mathbf{x}\\) (Entradas): Son las se\u00f1ales recibidas (ej. variables del cultivo o p\u00edxeles de una imagen).</p> </li> <li> <p>\\(\\mathbf{W}\\) (Matriz de Pesos): Es la \"memoria\" del modelo. Cada fila de \\(\\mathbf{W}\\) representa una neurona, y sus valores indican qu\u00e9 tanto importa cada entrada para esa neurona espec\u00edfica.</p> </li> <li> <p>\\(\\mathbf{z}\\) (Activaciones): Es la respuesta de las neuronas ante el est\u00edmulo \\(\\mathbf{x}\\).</p> </li> </ul>"},{"location":"operaciones-estructuras.html#ejemplo-aplicado-neuronas-expertas-en-evaluacion-administrativa","title":"Ejemplo aplicado: Neuronas \"Expertas\" en Evaluaci\u00f3n Administrativa","text":"<p>Imagine que una IA administrativa debe evaluar autom\u00e1ticamente propuestas de proyectos. El vector de entrada \\(\\mathbf{x}\\) contiene \\(n=4\\) variables presupuestales: \\((\\text{infraestructura}, \\text{capacitaci\u00f3n}, \\text{operaci\u00f3n}, \\text{monitoreo})\\).</p> <p>La red neuronal tiene una capa con \\(m=2\\) neuronas, donde cada una se ha especializado (aprendido) para detectar un criterio diferente:</p> <ol> <li> <p>Neurona 1: Eval\u00faa el \"Equilibrio Estrat\u00e9gico\".</p> </li> <li> <p>Neurona 2: Eval\u00faa la \"Sostenibilidad Ambiental\".</p> </li> </ol> <p>La matriz de pesos \\(\\mathbf{W} \\in \\mathbb{R}^{2 \\times 4}\\) codifica estas prioridades:</p> \\[\\mathbf{W} = \\begin{pmatrix} 0{,}3 &amp; 0{,}3 &amp; 0{,}3 &amp; 0{,}1 \\\\  % Neurona 1: Pondera todo por igual (busca equilibrio) 0{,}1 &amp; 0{,}2 &amp; 0{,}4 &amp; 0{,}3      % Neurona 2: Prioriza operaci\u00f3n y monitoreo (sostenibilidad) \\end{pmatrix}.\\] <p>Si llega una propuesta con el siguiente perfil de inversi\u00f3n (en millones):</p> \\[\\mathbf{x} = (300, 80, 220, 75)^\\top.\\] <p>El paso hacia adelante (forward pass) de la red calcula:</p> \\[\\mathbf{z} = \\mathbf{W} \\mathbf{x} = \\begin{pmatrix} (0{,}3)(300) + (0{,}3)(80) + (0{,}3)(220) + (0{,}1)(75) \\\\ (0{,}1)(300) + (0{,}2)(80) + (0{,}4)(220) + (0{,}3)(75) \\end{pmatrix} = \\begin{pmatrix} 187{,}5 \\\\ 156{,}5 \\end{pmatrix}.\\] <p>Interpretaci\u00f3n del resultado: El vector de salida \\(\\mathbf{z}\\) nos dice que esta propuesta tiene una puntuaci\u00f3n alta en equilibrio (\\(187{,}5\\)) y moderada en sostenibilidad (\\(156{,}5\\)).</p>"},{"location":"operaciones-estructuras.html#por-que-esto-es-fundamental","title":"Por qu\u00e9 esto es fundamental","text":"<p>Este mecanismo permite que una red neuronal transforme datos brutos en conceptos abstractos. En este ejemplo, pasamos de \"dinero en rubros\" (espacio de entrada \\(\\mathbb{R}^4\\)) a \"calidad estrat\u00e9gica\" (espacio de caracter\u00edsticas \\(\\mathbb{R}^2\\)). Durante el entrenamiento, el algoritmo de backpropagation ajusta los valores de la matriz \\(\\mathbf{W}\\) para minimizar el error en la evaluaci\u00f3n, \"aprendiendo\" as\u00ed los pesos ideales para clasificar proyectos correctamente.</p>"},{"location":"operaciones-estructuras.html#producto-de-matrices","title":"Producto de Matrices","text":"<p>Las matrices constituyen la estructura algebraica fundamental para representar datos tabulares, transformaciones lineales y relaciones entre variables en el contexto de la Inteligencia Artificial. A continuaci\u00f3n, se detallan las operaciones y propiedades esenciales para el modelado de datos.</p> <p>La multiplicaci\u00f3n de matrices act\u00faa como el motor computacional del aprendizaje profundo. Esta operaci\u00f3n no solo generaliza el producto punto, sino que permite ejecutar m\u00faltiples operaciones simult\u00e1neamente (lo que conocemos como procesamiento en lote o batch) y realizar la composici\u00f3n de transformaciones lineales.</p>"},{"location":"operaciones-estructuras.html#regla-de-dimensiones","title":"Regla de Dimensiones","text":"<p>Para que el producto matricial \\(\\mathbf{A}\\mathbf{B}\\) est\u00e9 definido, las dimensiones internas deben coincidir (es decir, el n\u00famero de columnas de la primera debe igualar al n\u00famero de filas de la segunda):</p> \\[\\underbrace{\\mathbf{A}}_{m \\times \\mathbf{n}} \\quad \\times \\quad \\underbrace{\\mathbf{B}}_{\\mathbf{n} \\times p} \\quad = \\quad \\underbrace{\\mathbf{C}}_{m \\times p}\\]"},{"location":"operaciones-estructuras.html#definicion-formal_1","title":"Definici\u00f3n Formal","text":"<p>Dadas \\(\\mathbf{A} \\in \\mathbb{R}^{m \\times n}\\) y \\(\\mathbf{B} \\in \\mathbb{R}^{n \\times p}\\), su producto \\(\\mathbf{C} = \\mathbf{A}\\mathbf{B} \\in \\mathbb{R}^{m \\times p}\\) se define entrada por entrada. Como se ilustra conceptualmente en la Figura 1.5, el valor \\(c_{ij}\\) se obtiene mediante el producto punto entre la fila \\(i\\) de \\(\\mathbf{A}\\) y la columna \\(j\\) de \\(\\mathbf{B}\\):</p> \\[c_{ij} = \\mathbf{fila}_i(\\mathbf{A}) \\cdot \\mathbf{columna}_j(\\mathbf{B}) = \\sum_{k=1}^{n} a_{ik} b_{kj}.\\] Visualizaci\u00f3n del producto matricial. El elemento resultante $c_{ij}$ captura la interacci\u00f3n total entre la fila $i$ de la matriz izquierda y la columna $j$ de la matriz derecha. <p>Propiedades clave:</p> <ul> <li> <p>No Conmutatividad: En general, \\(\\mathbf{A}\\mathbf{B} \\neq \\mathbf{B}\\mathbf{A}\\). El orden importa: rotar y luego trasladar no es lo mismo que trasladar y luego rotar.</p> </li> <li> <p>Asociatividad: \\((\\mathbf{A}\\mathbf{B})\\mathbf{C} = \\mathbf{A}(\\mathbf{B}\\mathbf{C})\\). Esto es vital en Deep Learning para optimizar el c\u00f3mputo en capas profundas.</p> </li> </ul> <p>Ejemplo Pr\u00e1ctico: Lotes \\(\\times\\) Proveedores Imaginemos que queremos calcular costos para diferentes escenarios.</p> <ul> <li> <p>\\(\\mathbf{A}\\) (Requerimientos): 2 Lotes (filas) necesitan cantidades de 3 insumos (columnas: N, P, K).</p> </li> <li> <p>\\(\\mathbf{B}\\) (Precios): Esos 3 insumos tienen precios diferentes en 2 Proveedores distintos (columnas).</p> </li> </ul> \\[\\mathbf{A}_{(2 \\times 3)} =  \\begin{pmatrix}  10 &amp; 20 &amp; 5 \\\\  15 &amp; 10 &amp; 2  \\end{pmatrix}, \\quad \\mathbf{B}_{(3 \\times 2)} =  \\begin{pmatrix}  2 &amp; 3 \\\\  4 &amp; 4 \\\\  10 &amp; 8  \\end{pmatrix}\\] <p>El producto \\(\\mathbf{C} = \\mathbf{AB}\\) nos dar\u00e1 una matriz de \\(2 \\times 2\\) donde cada elemento \\(c_{ij}\\) es el costo total del Lote \\(i\\) comprando al Proveedor \\(j\\).</p> <p>Realizamos los c\u00e1lculos para cada celda: \\(\\(\\begin{aligned} c_{11} &amp;= (10\\cdot 2) + (20 \\cdot 4) + (5 \\cdot 10) = 20 + 80 + 50 = 150 \\\\ c_{12} &amp;= (10\\cdot 3) + (20 \\cdot 4) + (5 \\cdot 8) = 30 + 80 + 40 = 150 \\\\ c_{21} &amp;= (15\\cdot 2) + (10 \\cdot 4) + (2 \\cdot 10) = 30 + 40 + 20 = 90 \\\\ c_{22} &amp;= (15\\cdot 3) + (10 \\cdot 4) + (2 \\cdot 8) = 45 + 40 + 16 = 101 \\end{aligned}\\)\\)</p> <p>El resultado final es:</p> \\[\\mathbf{C} =  \\begin{pmatrix}  150 &amp; 150 \\\\  90 &amp; 101  \\end{pmatrix}\\] <p>Interpretaci\u00f3n para toma de decisiones:</p> <ul> <li> <p>Para el Lote 1 (Fila 1), ambos proveedores resultan en el mismo costo total ($150), aunque los precios unitarios sean distintos.</p> </li> <li> <p>Para el Lote 2 (Fila 2), es m\u00e1s econ\u00f3mico comprar al Proveedor 1 ($90) que al Proveedor 2 ($101).</p> </li> </ul> <p>Esta operaci\u00f3n permite evaluar m\u00faltiples escenarios econ\u00f3micos de forma simult\u00e1nea.</p>"},{"location":"operaciones-estructuras.html#escalares-asociados-traza-determinante-y-rango","title":"Escalares asociados: Traza, Determinante y Rango","text":"<p>Antes de analizar propiedades m\u00e1s complejas, definimos tres escalares que resumen la estructura de una matriz cuadrada \\(\\mathbf{A} \\in \\mathbb{R}^{n \\times n}\\):</p> <ul> <li> <p>Traza (\\(\\mathrm{tr}\\)): La suma de los elementos de la diagonal principal. En matrices de covarianza, representa la varianza total del sistema.</p> </li> <li> <p>Determinante (\\(\\det\\)): Una medida del cambio de volumen que produce la matriz como transformaci\u00f3n lineal. Si \\(\\det(\\mathbf{A}) = 0\\), la matriz \"aplasta\" el espacio y destruye informaci\u00f3n.</p> </li> <li> <p>Rango: El n\u00famero m\u00e1ximo de filas o columnas linealmente independientes. Indica la cantidad de informaci\u00f3n no redundante en los datos.</p> </li> </ul>"},{"location":"operaciones-estructuras.html#el-determinante","title":"El Determinante","text":"<p>El determinante es una funci\u00f3n escalar que asigna a cada matriz cuadrada \\(\\mathbf{A} \\in \\mathbb{R}^{n \\times n}\\) un n\u00famero real, denotado como \\(\\det(\\mathbf{A})\\) o \\(|\\mathbf{A}|\\). Este valor condensa informaci\u00f3n cr\u00edtica sobre la naturaleza geom\u00e9trica y algebraica de la matriz.</p>"},{"location":"operaciones-estructuras.html#interpretacion-geometrica","title":"Interpretaci\u00f3n geom\u00e9trica","text":"<p>En el contexto del an\u00e1lisis de datos, el determinante representa el factor de escala del volumen (o \u00e1rea en 2D) cuando la matriz \\(\\mathbf{A}\\) act\u00faa como una transformaci\u00f3n lineal.</p> <ul> <li> <p>Si \\(|\\det(\\mathbf{A})| &gt; 1\\), la transformaci\u00f3n expande el espacio.</p> </li> <li> <p>Si \\(0 &lt; |\\det(\\mathbf{A})| &lt; 1\\), la transformaci\u00f3n contrae el espacio.</p> </li> <li> <p>Si \\(\\det(\\mathbf{A}) = 0\\), la transformaci\u00f3n \"aplasta\" el volumen hasta convertirlo en una superficie, l\u00ednea o punto (p\u00e9rdida de dimensionalidad).</p> </li> </ul>"},{"location":"operaciones-estructuras.html#calculo-en-2-times-2","title":"C\u00e1lculo en \\(2 \\times 2\\)","text":"<p>Para una matriz de \\(\\mathbb{R}^{2 \\times 2}\\), la f\u00f3rmula es:</p> \\[\\begin{vmatrix}  a &amp; b \\\\  c &amp; d  \\end{vmatrix} = ad - bc\\]"},{"location":"operaciones-estructuras.html#singularidad-e-invertibilidad","title":"Singularidad e Invertibilidad","text":"<p>La propiedad m\u00e1s importante para la inteligencia artificial es su relaci\u00f3n con la inversi\u00f3n de matrices:</p> \\[\\mathbf{A} \\text{ es invertible} \\iff \\det(\\mathbf{A}) \\neq 0.\\] <p>Una matriz con determinante cero se llama singular. En t\u00e9rminos de datos, esto implica que las filas (o columnas) son linealmente dependientes, es decir, existe redundancia perfecta en la informaci\u00f3n (colinealidad).</p>"},{"location":"operaciones-estructuras.html#ejemplo-agro-ambiental-deteccion-de-redundancia","title":"Ejemplo Agro-Ambiental: Detecci\u00f3n de Redundancia","text":"<p>Suponga que intentamos modelar el crecimiento de un cultivo usando dos variables que creemos distintas: \\(x_1\\) (agua de riego en L) y \\(x_2\\) (tiempo de riego en minutos). Sin embargo, si el sistema de riego tiene un flujo constante, \\(x_1\\) es exactamente proporcional a \\(x_2\\).</p> <p>La matriz de correlaci\u00f3n o covarianza de estos datos tendr\u00eda la forma:</p> \\[\\mathbf{C} =  \\begin{pmatrix}  1 &amp; 1 \\\\  1 &amp; 1  \\end{pmatrix}.\\] <p>Calculando el determinante:</p> \\[\\det(\\mathbf{C}) = (1)(1) - (1)(1) = 0.\\] <p>El determinante nulo nos alerta matem\u00e1ticamente de que no tenemos dos dimensiones reales de informaci\u00f3n, sino solo una. Intentar invertir esta matriz para un modelo de regresi\u00f3n lineal generar\u00e1 un error computacional, indicando que debemos eliminar una de las variables redundantes antes de entrenar el modelo.</p>"},{"location":"operaciones-estructuras.html#inversa-de-una-matriz","title":"Inversa de una matriz","text":"<p>La inversa de una matriz cuadrada \\(\\mathbf{A} \\in \\mathbb{R}^{n \\times n}\\), denotada \\(\\mathbf{A}^{-1}\\), es la matriz \u00fanica que satisface:</p> \\[\\mathbf{A} \\mathbf{A}^{-1} = \\mathbf{A}^{-1} \\mathbf{A} = \\mathbf{I}_n,\\] <p>donde \\(\\mathbf{I}_n\\) es la matriz identidad (con 1s en la diagonal y 0s fuera).</p>"},{"location":"operaciones-estructuras.html#condicion-de-existencia","title":"Condici\u00f3n de existencia","text":"<p>Una matriz \\(\\mathbf{A}\\) es invertible (o no singular) si y solo si cumple cualquiera de estas condiciones equivalentes:</p> <ul> <li> <p>\\(\\det(\\mathbf{A}) \\neq 0\\),</p> </li> <li> <p>Su rango es completo (\\(\\mathrm{rango}(\\mathbf{A}) = n\\)),</p> </li> <li> <p>Sus columnas son linealmente independientes (no hay redundancia perfecta entre variables).</p> </li> </ul>"},{"location":"operaciones-estructuras.html#relevancia-en-ia","title":"Relevancia en IA","text":"<ul> <li> <p>Regresi\u00f3n Lineal: Los coeficientes \u00f3ptimos se estiman como \\(\\boldsymbol{\\beta} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}\\).</p> </li> <li> <p>Distancia de Mahalanobis: \\(\\sqrt{(\\mathbf{x}-\\boldsymbol{\\mu})^\\top \\mathbf{\\Sigma}^{-1} (\\mathbf{x}-\\boldsymbol{\\mu})}\\). Usada para detectar outliers multivariados (ej. animales enfermos con patrones fisiol\u00f3gicos at\u00edpicos).</p> </li> </ul> <p>Ejemplo agron\u00f3mico. Para predecir rendimiento (\\(y\\)) a partir de N y P (\\(\\mathbf{X}\\)), necesitamos calcular \\((\\mathbf{X}^\\top \\mathbf{X})^{-1}\\). Si</p> \\[\\mathbf{X}^\\top \\mathbf{X} = \\begin{pmatrix} 5 &amp; 2 \\\\ 2 &amp; 2 \\end{pmatrix} \\implies \\det = 10 - 4 = 6 \\neq 0.\\] <p>Como el determinante es no nulo, la inversa existe y el modelo tiene soluci\u00f3n \u00fanica:</p> \\[(\\mathbf{X}^\\top \\mathbf{X})^{-1} = \\frac{1}{6} \\begin{pmatrix} 2 &amp; -2 \\\\ -2 &amp; 5 \\end{pmatrix}.\\]"},{"location":"operaciones-estructuras.html#implementacion-en-python-operaciones-matriciales","title":"Implementaci\u00f3n en Python: Operaciones Matriciales","text":"<p>En el ecosistema de Python cient\u00edfico (NumPy), las operaciones matriciales est\u00e1n altamente optimizadas. A diferencia de otros lenguajes donde se requieren bucles, aqu\u00ed operamos directamente sobre las estructuras de datos.</p>"},{"location":"operaciones-estructuras.html#el-operador-producto","title":"El Operador Producto (@)","text":"<p>Desde Python 3.5, el est\u00e1ndar para la multiplicaci\u00f3n de matrices es el operador arroba (<code>@</code>). Este operador verifica autom\u00e1ticamente la consistencia de las dimensiones internas.</p>"},{"location":"operaciones-estructuras.html#algebra-lineal-con-numpylinalg","title":"\u00c1lgebra Lineal con <code>numpy.linalg</code>","text":"<p>Para operaciones m\u00e1s avanzadas como determinantes, trazas e inversas, utilizamos el subm\u00f3dulo de \u00e1lgebra lineal. A continuaci\u00f3n, se presenta una implementaci\u00f3n completa.</p> <pre><code>import numpy as np\n\n# --- 1. PRODUCTO MATRICIAL (@) ---\n# Matriz A (2x3) y B (3x2)\nA = np.array([[10, 20, 5], \n              [15, 10, 2]])\nB = np.array([[2, 3], \n              [4, 4], \n              [10, 8]])\n\n# Producto punto generalizado\nC = A @ B\nprint(f\"Producto C (2x2):\\n{C}\\n\")\n\n# --- 2. PROPIEDADES ---\n# Ejemplo A: Matriz 2x2\nM_2x2 = np.array([[4, 1],\n                  [2, 3]])\n\n# Traza (suma diagonal) y Determinante\ntraza_2 = np.trace(M_2x2)       \ndet_2   = np.linalg.det(M_2x2)  \n\nprint(f\"Matriz 2x2 -&gt; Traza: {traza_2}, Det: {det_2:.2f}\")\n\n# --- 3. INVERSA Y VERIFICACI\u00d3N ---\nM_3x3 = np.array([[1, 0, 2], [0, 3, 1], [2, 1, 0]])\ndet_3 = np.linalg.det(M_3x3)\n\nif det_3 != 0:\n    M_inv = np.linalg.inv(M_3x3)\n\n    # VERIFICACI\u00d3N: A @ A_inv = Identidad\n    # Usamos allclose por precisi\u00f3n flotante\n    identidad_calc = M_3x3 @ M_inv\n    es_identidad = np.allclose(identidad_calc, np.eye(3))\n\n    print(f\"\u00bfEs Identidad? {es_identidad}\")\nelse:\n    print(\"Matriz singular.\")\n</code></pre> <p>Nota sobre Punto Flotante</p> Al calcular la inversa, es com\u00fan obtener n\u00fameros como `0.9999999` en lugar de `1.0` debido a la precisi\u00f3n finita de las computadoras. Por eso, en lugar de comparar con `==`, utilizamos `np.allclose()` para verificar si el resultado es matem\u00e1ticamente correcto dentro de una tolerancia aceptable."},{"location":"operaciones-estructuras.html#errores-comunes-y-buenas-practicas","title":"Errores comunes y buenas pr\u00e1cticas","text":"<ol> <li> <p>El operador correcto: No confunda el operador <code>@</code> con el asterisco <code>*</code>.</p> <ul> <li> <p><code>A @ B</code>: Producto matricial (fila por columna).</p> </li> <li> <p><code>A * B</code>: Producto elemento a elemento (requiere mismas dimensiones exactas o broadcasting).</p> </li> </ul> </li> <li> <p>Gesti\u00f3n de dimensiones: Si intenta multiplicar matrices incompatibles, NumPy arrojar\u00e1 un error. Es vital verificar siempre <code>.shape</code>.</p> <pre><code># Intentar multiplicar A por s\u00ed misma: (2x3) @ (2x3)\ntry:\n    Error = A @ A \nexcept ValueError as e:\n    print(''Error de dimensi\u00f3n:'', e)\n\n# Salida:\n# ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0...\n# (size 3 is different from 2)\n</code></pre> </li> </ol> <p>::: tcolorbox En el c\u00f3digo de redes neuronales (como TensorFlow o PyTorch), la operaci\u00f3n <code>capa_oculta @ pesos</code> ocurre millones de veces por segundo. La eficiencia de esta operaci\u00f3n es la raz\u00f3n por la que usamos GPUs (Tarjetas Gr\u00e1ficas), ya que est\u00e1n dise\u00f1adas por hardware para realizar multiplicaciones de matrices en paralelo masivo. :::</p>"},{"location":"operaciones-estructuras.html#operaciones-con-tensores-en-bioingenieria","title":"Operaciones con Tensores en Bioingenier\u00eda","text":"<p>A diferencia de las matrices, donde el producto punto es la estrella, en los tensores operamos frecuentemente con filtrado (convoluci\u00f3n), operaciones elemento a elemento (Hadamard) y re-dimensionamiento (Reshaping).</p> <p>Caso de Estudio: Detecci\u00f3n de Tumores en MRI Una Resonancia Magn\u00e9tica (MRI) del cerebro no es una foto plana; es una volumetr\u00eda. Podemos representarla como un tensor \\(\\mathcal{X}\\) de dimensiones \\(256 \\times 256 \\times 120\\):</p> <ul> <li> <p>\\(256 \\times 256\\): Resoluci\u00f3n de cada \"rebanada\" (slice) de imagen (alto \\(\\times\\) ancho).</p> </li> <li> <p>\\(120\\): El n\u00famero de rebanadas tomadas desde la base del cr\u00e1neo hasta la coronilla (profundidad).</p> </li> </ul> <p>Operaci\u00f3n 1: Aplicaci\u00f3n de una M\u00e1scara (Producto Hadamard) Para aislar el cerebro y eliminar el cr\u00e1neo o el fondo, multiplicamos el tensor de la imagen \\(\\mathcal{X}\\) por un tensor binario \"m\u00e1scara\" \\(\\mathcal{M}\\) (donde 1 es tejido cerebral y 0 es hueso/fondo).</p> \\[\\mathcal{Y} = \\mathcal{X} \\odot \\mathcal{M} \\quad \\implies \\quad y_{ijk} = x_{ijk} \\cdot m_{ijk}\\] <p>Esta operaci\u00f3n se realiza simult\u00e1neamente en los 7.8 millones de v\u00f3xeles (p\u00edxeles 3D).</p> <p>Operaci\u00f3n 2: Aplanado (Flattening) para Diagn\u00f3stico Una red neuronal cl\u00e1sica no puede \"tragar\" un cubo. Debemos convertir el tensor 3D en un vector largo 1D para clasificarlo (ej. \u00bfHay tumor? S\u00ed/No).</p> \\[\\text{Flatten}(\\mathbb{R}^{256 \\times 256 \\times 120}) \\to \\mathbb{R}^{7,864,320}\\] <p>Este proceso de reestructurar los datos sin perder informaci\u00f3n es la base de la arquitectura de redes convolucionales (CNN).</p>"},{"location":"operaciones-estructuras.html#implementacion-manipulacion-de-voxeles-en-python","title":"Implementaci\u00f3n: Manipulaci\u00f3n de V\u00f3xeles en Python","text":"<p>En Python, bibliotecas como <code>NumPy</code>, <code>TensorFlow</code> o <code>PyTorch</code> tratan estas estructuras de forma nativa. N\u00f3tese que aqu\u00ed usamos el t\u00e9rmino <code>shape</code> (forma) para describir las dimensiones del tensor.</p> <pre><code>import numpy as np\n\n# 1. Simular una MRI cerebral (Tensor 3D)\n# Dimensiones: (Alto, Ancho, Profundidad)\n# Valores aleatorios simulando intensidad de se\u00f1al\nmri_tensor = np.random.rand(256, 256, 120)\n\nprint(f''Forma original del tensor: {mri_tensor.shape}'')\n# Salida: (256, 256, 120)\n\n# 2. Operaci\u00f3n de Slicing (Rebanado)\n# El m\u00e9dico quiere ver solo la rebanada central (corte axial)\ncorte_central = mri_tensor[:, :, 60] \n\nprint(f''Forma del corte 2D: {corte_central.shape}'')\n# Salida: (256, 256) -&gt; Ahora es una matriz cl\u00e1sica\n\n# 3. Operaci\u00f3n de M\u00e1scara (Thresholding)\n# Queremos resaltar solo tejidos con alta intensidad (posibles anomal\u00edas)\n# Creamos una m\u00e1scara booleana (Tensor de True/False)\nmascara_tejido = mri_tensor &gt; 0.8\n\n# Aplicamos la m\u00e1scara (Hadamard product impl\u00edcito)\ntejido_resaltado = mri_tensor * mascara_tejido\n\n# 4. Flattening (Preparar para IA)\ninput_vector = mri_tensor.flatten()\n\nprint(f''Vector de entrada para la Red Neuronal: {input_vector.shape}'')\n# Salida: (7864320,) -&gt; Un vector gigante\n</code></pre> <p>::: tcolorbox El peligro de los tensores es la explosi\u00f3n combinatoria. Un tensor 3D peque\u00f1o (\\(256^3\\)) consume pocos MB, pero a\u00f1adir una dimensi\u00f3n m\u00e1s (ej. tiempo en un video 4K) puede desbordar la memoria RAM de cualquier computadora est\u00e1ndar. Por eso, en IA, el dise\u00f1o eficiente de la shape del tensor es cr\u00edtico. :::</p>"},{"location":"operaciones-estructuras.html#ejercicios-y-proyectos-computacionales","title":"Ejercicios y Proyectos Computacionales","text":"<p>En esta secci\u00f3n, saldremos de la teor\u00eda abstracta para resolver problemas reales de ingenier\u00eda agroambiental. El objetivo es modelar situaciones de campo utilizando vectores y matrices, y resolverlas mediante la implementaci\u00f3n computacional en Python.</p>"},{"location":"operaciones-estructuras.html#ejercicio-1-planificacion-de-fertilizantes-combinacion-lineal","title":"Ejercicio 1: Planificaci\u00f3n de Fertilizantes (Combinaci\u00f3n Lineal)","text":"Aplicaci\u00f3n: Nutrici\u00f3n de Suelos Un ingeniero agr\u00f3nomo dispone de tres tipos de fertilizantes comerciales con distintas concentraciones de Nitr\u00f3geno (N), F\u00f3sforo (P) y Potasio (K). Necesitamos calcular el perfil nutricional final al mezclar distintas cantidades de estos productos.  <p>Datos del problema: Los fertilizantes tienen las siguientes composiciones (vectores en \\(\\mathbb{R}^3\\)):</p> <ul> <li> <p>Fertilizante A (Urea+): \\(\\mathbf{v}_A = [46, 0, 0]\\)</p> </li> <li> <p>Fertilizante B (DAP): \\(\\mathbf{v}_B = [18, 46, 0]\\)</p> </li> <li> <p>Fertilizante C (Potasa): \\(\\mathbf{v}_C = [0, 0, 60]\\)</p> </li> </ul> <p>Tarea Computacional: Escriba un script en Python que:</p> <ol> <li> <p>Defina estos vectores como arreglos de NumPy.</p> </li> <li> <p>Calcule el vector de nutrientes totales \\(\\mathbf{v}_{total}\\) si se aplican: \\(10\\) kg del A, \\(5\\) kg del B y \\(8\\) kg del C.</p> </li> <li> <p>Imprima el resultado interpretado (Total de N, P y K).</p> </li> </ol> <pre><code>import numpy as np\n\n# Definicion de vectores\nv_A = np.array([46, 0, 0])\nv_B = np.array([18, 46, 0])\nv_C = np.array([0, 0, 60])\n\n# Coeficientes (escalares en kg)\nc_A, c_B, c_C = 10, 5, 8\n\n# Combinacion Lineal\nv_total = (c_A * v_A) + (c_B * v_B) + (c_C * v_C)\n\nprint(f\"Perfil Nutricional Total (N-P-K): {v_total}\")\n</code></pre>"},{"location":"operaciones-estructuras.html#ejercicio-2-eficiencia-energetica-solar-producto-punto","title":"Ejercicio 2: Eficiencia Energ\u00e9tica Solar (Producto Punto)","text":"Aplicaci\u00f3n: Automatizaci\u00f3n de Invernaderos Para maximizar la fotos\u00edntesis en un invernadero automatizado o la energ\u00eda en paneles solares, el \u00e1ngulo de incidencia de la luz es vital. La eficiencia es m\u00e1xima cuando los rayos golpean perpendicularmente la superficie. Matem\u00e1ticamente, esto se relaciona con el coseno del \u00e1ngulo entre el vector normal de la superficie y el vector de la luz.  <p>Tarea Computacional: Dados dos vectores en 3D que representan la direcci\u00f3n de los rayos solares (\\(\\mathbf{s}\\)) y la orientaci\u00f3n normal del panel (\\(\\mathbf{p}\\)): \\(\\(\\mathbf{s} = [2, 3, -5] \\quad \\text{y} \\quad \\mathbf{p} = [1, 2, 1]\\)\\)</p> <p>1. Calcule la norma (magnitud) de ambos vectores. 2. Calcule el producto punto \\(\\mathbf{s} \\cdot \\mathbf{p}\\). 3. Encuentre el \u00e1ngulo \\(\\theta\\) entre ellos usando la f\u00f3rmula: \\(\\(\\cos(\\theta) = \\frac{\\mathbf{s} \\cdot \\mathbf{p}}{\\|\\mathbf{s}\\| \\|\\mathbf{p}\\|}\\)\\) 4. Determine si la orientaci\u00f3n es eficiente (consideraremos eficiente si \\(\\theta &lt; 45^\\circ\\) o \\(&gt; 135^\\circ\\), dependiendo de la direcci\u00f3n de referencia).</p>"},{"location":"operaciones-estructuras.html#ejercicio-3-prediccion-de-cosecha-multiplicacion-matriz-vector","title":"Ejercicio 3: Predicci\u00f3n de Cosecha (Multiplicaci\u00f3n Matriz-Vector)","text":"Aplicaci\u00f3n: Modelado Predictivo Las redes neuronales simples a menudo comienzan como una multiplicaci\u00f3n matricial. Supongamos que queremos predecir el rendimiento (toneladas/ha) de 3 lotes diferentes bas\u00e1ndonos en 2 variables: Humedad del suelo y Horas de sol.  <p>Modelo Matem\u00e1tico: \\(\\(\\mathbf{Y} = \\mathbf{X} \\cdot \\mathbf{w} + b\\)\\) Donde:</p> <ul> <li> <p>\\(\\mathbf{X}\\) es la matriz de datos (\\(3 \\text{ lotes} \\times 2 \\text{ variables}\\)).</p> </li> <li> <p>\\(\\mathbf{w}\\) es el vector de \\\"pesos\\\" o importancia (\\(\\mathbf{w} \\in \\mathbb{R}^2\\)).</p> </li> <li> <p>\\(b\\) es el sesgo (bias), un ajuste base.</p> </li> </ul> <p>Datos: \\(\\(\\mathbf{X} = \\begin{bmatrix}  0.8 &amp; 120 \\\\  0.6 &amp; 150 \\\\  0.9 &amp; 100  \\end{bmatrix}, \\quad \\mathbf{w} = \\begin{bmatrix} 5 \\\\ 0.02 \\end{bmatrix}, \\quad b = 1.5\\)\\)</p> <p>Tarea Computacional: Implemente esta operaci\u00f3n usando el operador '@' de Python o 'torch.matmul'. \u00bfCu\u00e1l es el rendimiento predicho para el segundo lote?</p>"},{"location":"operaciones-estructuras.html#ejercicio-4-el-problema-de-la-mezcla-inversa-sistemas-lineales","title":"Ejercicio 4: El Problema de la Mezcla Inversa (Sistemas Lineales)","text":"Aplicaci\u00f3n: Ingenier\u00eda Inversa A menudo sabemos qu\u00e9 resultado queremos (ej. un suelo con 50ppm de Nitr\u00f3geno y 30ppm de F\u00f3sforo) y necesitamos saber cu\u00e1nto fertilizante comprar. Esto requiere invertir la matriz de composici\u00f3n.  <p>Se tiene el sistema lineal \\(\\mathbf{A}\\mathbf{x} = \\mathbf{b}\\), donde:</p> <ul> <li> <p>\\(\\mathbf{A}\\): Matriz de composici\u00f3n de 2 fertilizantes (columnas) para 2 nutrientes (filas).</p> </li> <li> <p>\\(\\mathbf{b}\\): Vector de requerimientos del suelo (lo que queremos lograr).</p> </li> <li> <p>\\(\\mathbf{x}\\): Cantidad desconocida de cada fertilizante a aplicar.</p> </li> </ul> \\[\\mathbf{A} = \\begin{bmatrix} 0.5 &amp; 0.2 \\\\ 0.1 &amp; 0.4 \\end{bmatrix}, \\quad \\mathbf{b} = \\begin{bmatrix} 10 \\\\ 5 \\end{bmatrix}\\] <p>Tarea: 1. Verifique si la matriz \\(\\mathbf{A}\\) es invertible calculando su determinante ('np.linalg.det'). 2. Si es distinto de cero, calcule \\(\\mathbf{x}\\) usando la inversa: \\(\\mathbf{x} = \\mathbf{A}^{-1}\\mathbf{b}\\). 3. Verifique su resultado recalculando \\(\\mathbf{A} \\cdot \\mathbf{x}\\) y compar\u00e1ndolo con \\(\\mathbf{b}\\).</p>"},{"location":"regresion_lineal.html","title":"Ajuste de Modelos: Cuando el Sistema no es Perfecto","text":"<p>En el cap\u00edtulo anterior, asumimos que nuestros sensores eran perfectos y que pod\u00edamos encontrar una soluci\u00f3n exacta para \\(A\\mathbf{x}=\\mathbf{b}\\). Sin embargo, en un campo de cultivo real, dos plantas con la misma cantidad de agua y nutrientes pueden crecer diferente debido a factores aleatorios (gen\u00e9tica, viento, plagas).</p> <p>Aqu\u00ed entramos en el terreno de la **Ciencia de Datos**: rara vez buscamos una soluci\u00f3n exacta (que no existe); buscamos la **mejor soluci\u00f3n aproximada**.</p>"},{"location":"regresion_lineal.html#intuicion-el-problema-del-sistema-sobredeterminado","title":"Intuici\u00f3n: El Problema del Sistema Sobredeterminado","text":"<p>Imagina que quieres predecir el rendimiento de ma\u00edz (\\(y\\)) bas\u00e1ndote en la cantidad de Nitr\u00f3geno aplicado (\\(x\\)). Tomas 100 muestras en el campo. Esto genera un sistema de ecuaciones con 100 ecuaciones (una por muestra) pero solo 2 inc\u00f3gnitas (la pendiente y la intersecci\u00f3n de la recta: \\(y = mx + c\\)).</p> \\[\\begin{bmatrix} x_1 &amp; 1 \\\\ x_2 &amp; 1 \\\\ \\vdots &amp; \\vdots \\\\ x_{100} &amp; 1 \\end{bmatrix} \\begin{bmatrix} m \\\\ c \\end{bmatrix} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_{100} \\end{bmatrix}\\] <p>Matem\u00e1ticamente, esto es una matriz \\(A\\) alta y delgada (\\(100 \\times 2\\)). Es un sistema **sobredeterminado**. No existe una l\u00ednea recta que pase exactamente por los 100 puntos a la vez. El vector \\(\\mathbf{b}\\) no vive en el espacio columna de \\(A\\).</p>"},{"location":"regresion_lineal.html#formalizacion-ecuaciones-normales","title":"Formalizaci\u00f3n: Ecuaciones Normales","text":"<p>Ya que no podemos hacer que el error sea cero, tratamos de que sea lo m\u00e1s peque\u00f1o posible. Definimos el error (residuo) como la distancia entre lo que predice nuestro modelo (\\(A\\hat{\\mathbf{x}}\\)) y la realidad (\\(\\mathbf{b}\\)):</p> \\[\\mathbf{e} = \\mathbf{b} - A\\hat{\\mathbf{x}}\\] <p>Para minimizar la longitud de este vector de error (\\(||\\mathbf{e}||^2\\)), utilizamos c\u00e1lculo o geometr\u00eda proyectiva para llegar a las famosas **Ecuaciones Normales**:</p> <p>\ud83c\udf3f La Ecuaci\u00f3n Maestra del Machine Learning Cl\u00e1sico</p> La mejor aproximaci\u00f3n $\\hat{\\mathbf{x}}$ se encuentra resolviendo: $$A^T A \\hat{\\mathbf{x}} = A^T \\mathbf{b}$$  <p>Nota que \\(A^T A\\) es una matriz cuadrada y sim\u00e9trica, lo que (casi siempre) nos permite resolver el sistema.</p>"},{"location":"regresion_lineal.html#conexion-agro-mecatronica","title":"Conexi\u00f3n Agro-Mecatr\u00f3nica","text":"Aplicaci\u00f3n: Calibraci\u00f3n de Sensores de Humedad Capacitivos Los sensores de humedad de suelo baratos devuelven un voltaje anal\u00f3gico. Para convertir ese voltaje a \\\"Porcentaje de Humedad Volum\u00e9trica\\\", necesitamos calibrarlos. 1. Tomamos muestras de suelo con humedades conocidas (10%, 20%, \\..., 50%). 2. Medimos el voltaje en cada muestra. 3. Usamos M\u00ednimos Cuadrados para encontrar la ecuaci\u00f3n $Humedad = m \\cdot Voltaje + c$ que minimice el error de lectura."},{"location":"regresion_lineal.html#implementacion-prediccion-de-rendimiento","title":"Implementaci\u00f3n: Predicci\u00f3n de Rendimiento","text":"<p>Vamos a usar datos simulados para encontrar la relaci\u00f3n entre agua de riego y producci\u00f3n de biomasa usando las Ecuaciones Normales (sin librer\u00edas de caja negra primero) y luego validando con Scikit-Learn.</p> <pre><code>import numpy as np\n\n# 1. DATOS DE CAMPO (Simulados)\n# X: Litros de agua/semana, y: Kg de biomasa\nX_raw = np.array([10, 15, 20, 25, 30, 35])\ny = np.array([1.2, 1.8, 2.5, 3.1, 3.4, 4.0])\n\n# 2. CONSTRUCCI\u00d3N DE LA MATRIZ DE DISE\u00d1O A\n# Necesitamos agregar una columna de 1s para el t\u00e9rmino independiente (intercepto)\n# A tendr\u00e1 forma (6 filas, 2 columnas)\nones = np.ones(len(X_raw))\nA = np.column_stack((X_raw, ones))\n\nprint(\"Matriz A (Dise\u00f1o):\")\nprint(A[:3]) # Mostramos solo las primeras 3 filas\n\n# 3. ECUACIONES NORMALES: (A^T * A) * x = (A^T * b)\n# Paso A: Calcular A transpuesta por A\nAt_A = np.dot(A.T, A)\n\n# Paso B: Calcular A transpuesta por y\nAt_y = np.dot(A.T, y)\n\n# Paso C: Resolver el sistema lineal cuadrado resultante\n# Usamos np.linalg.solve (que usa Descomposici\u00f3n LU internamente)\ntheta = np.linalg.solve(At_A, At_y)\n\npendiente = theta[0]\nintercepto = theta[1]\n\n# 4. PREDICCI\u00d3N\nagua_nueva = 40 # Litros\nprediccion = pendiente * agua_nueva + intercepto\n</code></pre> <pre><code>Matriz A (Dise\u00f1o):\n[[10.  1.]\n [15.  1.]\n [20.  1.]]\n\nModelo encontrado:\nBiomasa = 0.110 * Agua + 0.205\n\nPredicci\u00f3n para 40L de agua:\n4.62 Kg de biomasa\n</code></pre> <p>Atenci\u00f3n: Correlaci\u00f3n no implica Causalidad</p> Un $R^2$ alto en nuestro modelo matem\u00e1tico no significa que el agua sea la \u00fanica causa del crecimiento. Si ignoramos plagas o temperatura, el modelo fallar\u00e1 en producci\u00f3n real. El \u00e1lgebra lineal no tiene sentido com\u00fan biol\u00f3gico."},{"location":"sistemas_ecuaciones.html","title":"Intuici\u00f3n Geom\u00e9trica y Notaci\u00f3n Matricial","text":"<p>Un sistema de ecuaciones lineales puede interpretarse geom\u00e9tricamente como un conjunto de planos (en \\(\\mathbb{R}^3\\)) o, en general, hiperplanos (en \\(\\mathbb{R}^n\\)). Resolver el sistema equivale a encontrar el punto ---o conjunto de puntos--- donde todos estos objetos geom\u00e9tricos se intersecan simult\u00e1neamente.</p> <p>Seg\u00fan la configuraci\u00f3n relativa, pueden darse tres situaciones fundamentales (ver Figura [fig:tipos_soluciones]):</p> <ul> <li> <p>Soluci\u00f3n \u00fanica: Los planos se intersecan en un \u00fanico punto (sistema compatible determinado).</p> </li> <li> <p>Infinitas soluciones: Los planos comparten una recta o un eje com\u00fan, como las p\u00e1ginas de un libro abierto (sistema compatible indeterminado).</p> </li> <li> <p>Sin soluci\u00f3n: No existe un punto com\u00fan a todos; por ejemplo, planos paralelos como los pisos de un edificio o formando un prisma triangular (sistema incompatible).</p> </li> </ul> <p>En la figura 1 se ilustra la interpretaci\u00f3n en 3D, donde cada ecuaci\u00f3n representa un plano en el espacio tridimensional. La soluci\u00f3n del sistema corresponde al punto (o conjunto de puntos) donde estos planos se intersectan. Si la soluci\u00f3n es \u00fanica, los planos se cruzan en un solo punto; si hay infinitas soluciones, los planos se intersectan a lo largo de una l\u00ednea o plano com\u00fan; y si no hay soluci\u00f3n, los planos no se intersectan en absoluto.</p> Intersecci\u00f3n en 3D (Planos)."},{"location":"sistemas_ecuaciones.html#el-concepto-de-hiperplano-y-la-ceguera-dimensional","title":"El concepto de Hiperplano y la Ceguera Dimensional","text":"<p>Mientras que en 2D visualizamos rectas y en 3D planos, los problemas reales en agroambiental (como datos satelitales con 12 bandas espectrales) o mecatr\u00f3nica (un robot con 7 grados de libertad) habitan en espacios de dimensi\u00f3n superior.</p> <p>Aqu\u00ed surge el concepto de hiperplano: una generalizaci\u00f3n matem\u00e1tica que representa un subespacio \"plano\" de dimensi\u00f3n \\(n-1\\) en un espacio de dimensi\u00f3n \\(n\\). Aunque nuestra intuici\u00f3n biol\u00f3gica est\u00e1 limitada a tres dimensiones, el \u00e1lgebra lineal no sufre esta restricci\u00f3n. La ecuaci\u00f3n: \\(\\(2x_1 + 5x_2 - x_3 + 8x_4 = 10\\)\\) describe un hiperplano en \\(\\mathbb{R}^4\\). No podemos dibujarlo, pero podemos operar con \u00e9l algebraicamente con la misma facilidad que con una recta. El \u00e1lgebra se convierte as\u00ed en nuestros \"ojos\" que nos permite ver y manipular estructuras en dimensiones que nuestro cerebro no puede concebir.</p>"},{"location":"sistemas_ecuaciones.html#1-eliminacion-gaussiana-el-algoritmo-paso-a-paso","title":"1. Eliminaci\u00f3n Gaussiana (El Algoritmo Paso a Paso)","text":"<p>Este es el algoritmo fundamental. Su objetivo es transformar un problema complejo (sistema acoplado) en uno sencillo (sistema triangular) mediante operaciones que no alteran la soluci\u00f3n.</p> <p>El proceso tiene dos fases:</p> <ol> <li> <p>Eliminaci\u00f3n hacia adelante: Convertir la matriz original \\(A\\) en una matriz triangular superior \\(U\\) (hacer ceros debajo de la diagonal).</p> </li> <li> <p>Sustituci\u00f3n hacia atr\u00e1s: Despejar las inc\u00f3gnitas empezando por la \u00faltima ecuaci\u00f3n.</p> </li> </ol>"},{"location":"sistemas_ecuaciones.html#ejemplo-pr\u00e1ctico-3x3","title":"Ejemplo Pr\u00e1ctico 3x3","text":"<p>Consideremos el siguiente sistema. Para manipularlo num\u00e9ricamente, formamos la matriz aumentada \\([A|\\mathbf{b}]\\), que incluye los t\u00e9rminos independientes:</p> \\[\\begin{cases} 2x_1 + \\phantom{1}x_2 + \\phantom{1}x_3 = 4 \\\\ 4x_1 - 6x_2 \\phantom{+ 0x_3} = -2 \\\\ -2x_1 + 7x_2 + 2x_3 = 7 \\end{cases} \\implies \\left[ \\begin{array}{ccc|c} \\mathbf{2} &amp; 1 &amp; 1 &amp; 4 \\\\ 4 &amp; -6 &amp; 0 &amp; -2 \\\\ -2 &amp; 7 &amp; 2 &amp; 7 \\end{array} \\right]\\] <p>Paso 1: Primer Pivote (Columna 1)\\ Nuestro objetivo es eliminar los n\u00fameros debajo del primer elemento de la diagonal (el 2, llamado pivote).</p> <ul> <li> <p>Para eliminar el \\(4\\) (Fila 2): Hacemos \\(F_2 \\leftarrow F_2 - 2F_1\\).</p> </li> <li> <p>Para eliminar el \\(-2\\) (Fila 3): Hacemos \\(F_3 \\leftarrow F_3 + F_1\\).</p> </li> </ul> \\[\\left[ \\begin{array}{ccc|c} 2 &amp; 1 &amp; 1 &amp; 4 \\\\ \\mathbf{0} &amp; -8 &amp; -2 &amp; -10 \\\\ \\mathbf{0} &amp; 8 &amp; 3 &amp; 11 \\end{array} \\right]\\] <p>Paso 2: Segundo Pivote (Columna 2)\\ Ahora nos enfocamos en la sub-matriz restante. El nuevo pivote es el \\(-8\\). Necesitamos eliminar el \\(8\\) que est\u00e1 debajo de \u00e9l.</p> <ul> <li>Operaci\u00f3n: \\(F_3 \\leftarrow F_3 + F_2\\).</li> </ul> \\[\\left[ \\begin{array}{ccc|c} 2 &amp; 1 &amp; 1 &amp; 4 \\\\ 0 &amp; -8 &amp; -2 &amp; -10 \\\\ 0 &amp; \\mathbf{0} &amp; 1 &amp; 1 \\end{array} \\right]\\] <p>\u00a1El sistema ya est\u00e1 triangulado! Observa que hemos obtenido ceros en el \\\"tri\u00e1ngulo\\\" inferior izquierdo.</p> <p>Paso 3: Sustituci\u00f3n hacia atr\u00e1s\\ Reescribimos el sistema equivalente que nos ha quedado, que ahora es trivial de resolver de abajo hacia arriba:</p> <p>1. Tercera ecuaci\u00f3n: \\(\\(1x_3 = 1 \\implies \\mathbf{x_3 = 1}\\)\\)</p> <p>2. Segunda ecuaci\u00f3n (sustituyendo \\(x_3\\)): \\(\\(-8x_2 - 2(1) = -10 \\implies -8x_2 = -8 \\implies \\mathbf{x_2 = 1}\\)\\)</p> <p>3. Primera ecuaci\u00f3n (sustituyendo \\(x_2, x_3\\)): \\(\\(2x_1 + 1 + 1 = 4 \\implies 2x_1 = 2 \\implies \\mathbf{x_1 = 1}\\)\\)</p> <p>La soluci\u00f3n del sistema es el vector \\(\\mathbf{x} = [1, 1, 1]^\\top\\). Computacionalmente, este proceso tiene una complejidad de \\(O(n^3)\\), lo que significa que si duplicamos el n\u00famero de variables, el tiempo de c\u00e1lculo se multiplica aproximadamente por 8. Aplicaci\u00f3n: Aplicaci\u00f3n: Balanceo de Cargas en Drones En el dise\u00f1o del chasis de un dron fumigador, las fuerzas est\u00e1ticas se resuelven mediante Gauss. Como la estructura del dron no cambia, el m\u00e9todo es directo y exacto para asegurar que los brazos soporten el tanque de l\u00edquido. </p>"},{"location":"sistemas_ecuaciones.html#2-metodo-de-la-matriz-inversa","title":"2. M\u00e9todo de la Matriz Inversa","text":"<p>Te\u00f3ricamente, si \\(A\\) es cuadrada y su determinante es no nulo (\\(\\det(A) \\neq 0\\)), existe una matriz \\(A^{-1}\\) tal que:</p> \\[\\mathbf{x} = A^{-1}\\mathbf{b}\\] <p>Aunque matem\u00e1ticamente elegante, computacionalmente es costoso. Calcular la inversa requiere muchas m\u00e1s operaciones que la eliminaci\u00f3n gaussiana.</p> <p>Advertencia Computacional</p> En sistemas grandes (ej. an\u00e1lisis de genoma vegetal o simulaci\u00f3n de fluidos), \\*\\*nunca\\*\\* se calcula la inversa expl\u00edcita. Es num\u00e9ricamente inestable y lenta. Se prefieren m\u00e9todos de descomposici\u00f3n."},{"location":"sistemas_ecuaciones.html#3-descomposicion-lu-lower-upper","title":"3. Descomposici\u00f3n LU (Lower-Upper)","text":"<p>Este es el m\u00e9todo \\\"rey\\\" en la ingenier\u00eda aplicada. Consiste en factorizar la matriz \\(A\\) en el producto de dos matrices triangulares: una inferior (\\(L\\)) y una superior (\\(U\\)). \\(\\(A = L \\cdot U\\)\\) Esto permite resolver el sistema en dos pasos r\u00e1pidos y baratos computacionalmente. Es ideal cuando tenemos una misma matriz \\(A\\) (ej. un robot) pero m\u00faltiples vectores \\(\\mathbf{b}\\) (diferentes posiciones objetivo).</p>"},{"location":"sistemas_ecuaciones.html#conexion-agro-mecatronica-sensores-espectrales","title":"Conexi\u00f3n Agro-Mecatr\u00f3nica: Sensores Espectrales","text":"<p>\ud83c\udf3f Calibraci\u00f3n de Sensores Multiespectrales</p> Imagina un sensor que mide la salud de una planta. El sensor tiene 3 fotodiodos, pero cada uno tiene una ligera \\\"contaminaci\u00f3n\\\" de otras longitudes de onda (crosstalk).  -   Lectura Diodo Rojo = $1.0 \\cdot \\text{RojoReal} + 0.1 \\cdot \\text{VerdeReal}$  -   Lectura Diodo Verde = $0.2 \\cdot \\text{RojoReal} + 0.9 \\cdot \\text{VerdeReal}$  Para recuperar los valores reales de luz (RojoReal, VerdeReal) a partir de las lecturas sucias del sensor, debemos resolver el sistema usando la matriz de calibraci\u00f3n inversa del fabricante."},{"location":"sistemas_ecuaciones.html#implementacion-en-python-numpy","title":"Implementaci\u00f3n en Python (NumPy)","text":"<p>A diferencia del cap\u00edtulo anterior donde usamos optimizaci\u00f3n (TensorFlow), aqu\u00ed usaremos \u00e1lgebra lineal exacta con **NumPy**, la librer\u00eda base de la ciencia de datos.</p> <pre><code>import numpy as np\n\n# 1. Definir el sistema (Ejemplo de calibraci\u00f3n de sensores)\n# Matriz de coeficientes (Crosstalk del sensor)\nA = np.array([\n    [1.0, 0.1, 0.05], # Diodo 1 sensible a Banda 1, 2 y 3\n    [0.2, 0.9, 0.1],  # Diodo 2\n    [0.1, 0.2, 0.8]   # Diodo 3\n])\n\n# Vector b (Lecturas crudas del sensor)\nb = np.array([500, 800, 300]) # Valores en milivoltios\n\n# 2. M\u00e9todo 1: Resoluci\u00f3n directa (Usa LU internamente - RECOMENDADO)\n# Es el metodo mas rapido y estable num\u00e9ricamente\nx_solve = np.linalg.solve(A, b)\n\n# 3. M\u00e9todo 2: Calculando la Inversa expl\u00edcita (NO RECOMENDADO para N grande)\nA_inv = np.linalg.inv(A)\nx_inv = np.dot(A_inv, b)\n\n# 4. Verificaci\u00f3n\nprint(\"--- Resultados de Calibraci\u00f3n ---\")\nprint(f\"Valores reales de luz: {x_solve}\")\n\n# Comprobamos si Ax = b\ncheck = np.dot(A, x_solve)\nprint(f\"Reconstrucci\u00f3n de lecturas (Check): {check}\")\nprint(f\"Error num\u00e9rico: {np.allclose(check, b)}\")\n</code></pre>"}]}